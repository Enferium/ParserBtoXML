options {
	STATIC = false;
	VISITOR=true;
	VISITOR_EXCEPTION = "ParserBException";
	NODE_DEFAULT_VOID=true;
	MULTI = true;
	DEBUG_PARSER = true; // (default false)
	LOOKAHEAD = 3;
	FORCE_LA_CHECK = true;
}


PARSER_BEGIN(ParserB)

package grammaire ;

import java.io.*;
import java.util.*;

public class ParserB {
  
	public JJTParserBState getJJTree()
	{
		return jjtree;
	}

	public Node getRoot()
	{
		return jjtree.rootNode();
	}
}

PARSER_END(ParserB)


SKIP : {
  < [" ", "\t", "\n", "\r", "\u00a0"] >
}

SKIP : {
	"/*" : WithinComment
}

<WithinComment> SKIP : {
	"*/" : DEFAULT
}

<WithinComment> MORE:
{
  < ~[] >
}

TOKEN : {

  	<Machine: "MACHINE">
|  	<End : "END">
|  	<Sets : "SETS">
|  	<Invariant : "INVARIANT">
|  	<Assert : "ASSERT">
|  	<Variables : "VARIABLES">
|  	<Operations : "OPERATIONS">
| 	<Events : "EVENTS">
|	<Constraints : "CONSTRAINTS">
|	<Constants : "CONSTANTS">
|	<Properties : "PROPERTIES">
|	<ConcreteVariables : "CONCRETE_VARIABLES">
|	<AbstractVariables : "ABSTRACT_VARIABLES">
|	<ConcreteConstants : "CONCRETE_CONSTANTS">
|	<AbstractConstants : "ABSTRACT_CONSTANTS">
|	<Initialisation : "INITIALISATION" >
|	<Definitions : "DEFINITIONS">
|	<Values : "VALUES">
|	<Begin : "BEGIN">
|	<Pre : "PRE">
|	<If : "IF">
|	<Then : "THEN">
|	<Elsif : "ELSIF">
|	<Else : "ELSE">
|	<Any : "ANY">
|	<Where : "WHERE">
|	<Let : "LET">
|	<Be : "BE">
|	<InLetVar : "IN">
|	<Choice : "CHOICE">
|	<OrC : "OR">
|	<Select : "SELECT">
|	<When : "WHEN">
|	<Case : "CASE">
|	<Of : "OF">
|	<Either : "EITHER">
|	<Var : "VAR">
|	<While : "WHILE">
|	<Do : "DO">
|	<Variant : "VARIANT">

|	<EmptySet : "{" (" ")* "}">
|	<EmptySequence : "[" (" ")* "]">
|	<EmptySequenceOld : "<>">


|	<Equivalence : "<=>">
|	<Subset : "<:">
|	<NotSubset : "/<:">
|	<Implication : "=>">
|	<StrictSubset : "<<:">
|	<NotStrictSubset : "/<<:">
|	<NotSetMemberShip : "/:">
|	<NotEqual : "/=">

|	<LessThanOrEqual : "<=">
|	<GreatherThanOrEqual : ">=">


|	<Relation : "<->">
|	<PartialSurjection : "+->>">
|	<PartialFunction: "+->">
|	<TotalSurjection : "-->>">
|	<TotalFunction : "-->">
|	<PartialBijection : ">+>>">
|	<PartialInjection : ">+>">
|	<TotalBijection : ">->>">
|	<TotalInjection : ">->">

|	<OperationReturn : "<--">
|	<DevientEgal : ":=">

|	<OpenCurly : "[">
|	<CloseCurly : "]">

|	<Maplet : "|->">

|	<DomainSubstraction : "<<|">
|	<DomainRestriction : "<|">
|	<RangeSubstraction : "|>>">
|	<RangeRestriction : "|>">
|	<Override : "<+">
|	<DirectProduct : "><">
|	<PrependSequence : "->">
|	<AppendSequence : "<-">
|	<PrefixSequence : "/|\\">
|	<SuffixSequence : "\\|/">

|	<SetIn : "::">
|	<EqualEqual : "==">
|	<NatRange : "..">
|	<Power : "**">

|	<Union : "\\/">
|	<Intersection : "/\\">

|	<Lambda : "%">
|	<SuchAs : "|">
|	<Forall : "!">
|	<Exists : "#">
|	<Tilde : "~">
|	<OpenBraces : "{">
|	<CloseBraces : "}">
|  	<Point : ".">
|  	<OpenParen : "(">
|  	<CloseParen : ")">
|	<Comma : ",">
|	<Or : "or">
|	<And  : "&">
|	<Not : "not">
|	<Skip : "skip">
|	<Minus : "-">
|	<Plus : "+">
|	<Product : "*">
|	<Division : "/">
|	<Modulo : "mod">
|	<Equal : "=">
|	<ConcatSequence : "^">
|	<LessThan : "<">
|	<GreatherThan : ">">

|	<In : ":">
|	<DollarZero : "$0">

| 	<Composition : "°">
|	<ParallelProduct : "//">
|	<SetMinus : "\\">

|	<Parallel : "||">
|	<SemiColon : ";">
|	<Quote : "'">

|	<Prj1 : "prj1">
|	<Prj2 : "prj2">
|	<POW : "POW">
|	<FIN : "FIN">
|	<POW1 : "POW1">
|	<FIN1 : "FIN1">
|	<InterGen : "inter">
|	<UnionGen : "union">
|	<UnionQuant : "UNION">
|	<InterQuant : "INTER">
|	<Id : "id">
|	<Dom : "dom">
|	<Ran : "ran">
|	<Iterate : "iterate">
|	<Closure : "closure">
|	<Closure1 : "closure1">
|	<Card : "card">
|	<Max : "max">
|	<Min : "min">
|   <Succ : "succ">
|	<Pred : "pred">
|	<Sigma : "SIGMA">
|	<Pi : "PI">
|	<Seq : "seq">
|	<Iseq : "iseq">
|	<Seq1 : "seq1">
|	<Iseq1 : "iseq1">
|	<Perm : "perm">
|	<Conc : "conc">
|	<Front : "front">
|	<Tail : "tail">
|	<First : "first">
|	<Last : "last">
|	<Size : "size">
|	<Rev : "rev">
|	<Fnc : "fnc">
|	<Rel : "rel">
|	<Rec : "rec">
|	<Struct : "struct">
|	<Bool : "bool">

|	<Nat : "NAT">
|	<Nat1 : "NAT1">
|	<Natural : "NATURAL">
|	<Natural1 : "NATURAL1">
|	<Int : "INT">
|	<Integer : "INTEGER">
|	<True : "TRUE">
|	<False : "FALSE">
|	<Boolean : "BOOL">
|	<StringSet : "STRING">
|	<MaxInt : "MAXINT">
|	<MinInt : "MININT">

| 	<Tree : "tree" >
| 	<Btree : "btree" >
| 	<Const : "const" > 
| 	<Top : "top" >
| 	<Sons : "sons" >
| 	< Prefix : "prefix"> 
| 	< Postfix : "postfix"> 
| 	< Sizet : "sizet" >
| 	< Mirror : "mirror" >
| 	< Rank : "rank" >
| 	< Father : "father" >
| 	< Son : "son" >
| 	< Subtree : "subtree" >
| 	< Arity : "arity" >
| 	< Bin : "bin" >
| 	< Left : "left" >
| 	< Right : "right" >
| 	< Infix : "infix" >
}

TOKEN : {
	<IDENTIFIER : ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_","0"-"9"])*>
}

TOKEN : {
	<String:
      		"\""
      		(         (~["\"","\\","\n","\r"])
        		| ("\\"
            			(   ["n","t","b","r","f","\\","'","\""]
            			  | ["0"-"7"] ( ["0"-"7"] )?
            			  | ["0"-"3"] ["0"-"7"] ["0"-"7"]
           			)
          		  )
      		)*
          	"\""
  	>
}

TOKEN : {
	<Number : (["0"-"9"])+ >
}

void Donnee() : { } {
	Ident_ren()
}

void Ident_ren() #Ident_ren : {Token t;} {
	t=< IDENTIFIER > (< Point > < IDENTIFIER > )*
	{jjtThis.setIdent(t.image);}
}

SimpleNode Machine_abstraite () #Machine(>1) : {} {
	<Machine> EnTete() (Clause_machine_abstraite())* <End>
	{ return jjtThis; }
}

void Clause_machine_abstraite() : {} {
	Clause_constraints()
|  	Clause_sets()
|  	Clause_concrete_constants()
|  	Clause_abstract_constants()
|  	Clause_properties()
|  	Clause_concrete_variables()
|  	Clause_abstract_variables()
|  	Clause_invariant()
|  	Clause_initialisation()
|  	Clause_operations()
}

void EnTete() #EnTete : {Token t;} {
	t=<IDENTIFIER> [<OpenParen> <IDENTIFIER>(<Comma> <IDENTIFIER>)* <CloseParen>]
	{jjtThis.setIdent(t.image);}
}

void Clause_constraints () #Constraints : {} {
	<Constraints> Predicat()
}

void Clause_sets () #Sets : {} {
	<Sets> Ensemble() (<SemiColon> Ensemble())*
}

void Ensemble() #Ensemble : {} {
  <IDENTIFIER> [<Equal> <OpenBraces> <IDENTIFIER> (<Comma> <IDENTIFIER>)*  <CloseBraces>]
}

void Clause_concrete_constants() #ConcreteConstants : {} {
	(<ConcreteConstants> | <Constants> ) <IDENTIFIER> (<Comma> <IDENTIFIER>)*
}

void Clause_abstract_constants() #AbstractConstants : {} {
	<AbstractConstants> <IDENTIFIER> (<Comma> <IDENTIFIER>)*
}

void Clause_properties() #Properties : {} {
	<Properties> Predicat()
}

void Clause_values() #Values : {} {
	<Values> Valuation() (<SemiColon> Valuation())*
}

void Valuation() #Value(1) : {} {
   < IDENTIFIER > <Equal> (Terme() | Expr_tableau())
}

void Clause_concrete_variables() #ConcreteVariables : {} {
	<ConcreteVariables> Ident_ren() (<Comma> Ident_ren())*
}

void Clause_abstract_variables() #AbstractVariables(>1) : {} {
	(<AbstractVariables> | <Variables>) Ident_ren() (<Comma> Ident_ren())*
}

void Clause_invariant() #Invariant(1) : {} {
	<Invariant> Predicat()
}

void Clause_initialisation() #Initialisation : {} {
	<Initialisation> Substitution()
}

void Clause_operations() #Operations  : {} {
	<Operations> Operation() (<SemiColon> Operation())*
}

void Operation() #Operation : {} {
	Entete_operation() <Equal> Substitution_corps_operation()
}

void Entete_operation() #EnteteOperation(1) : {} {
	[<IDENTIFIER> (<Comma> <IDENTIFIER>)* <OperationReturn> ] Ident_ren()
	 [<OpenParen> <IDENTIFIER>(<Comma> <IDENTIFIER>)* <CloseParen>]
}

void Terme() #Terme : {} {
	Terme_simple()
| 	Expression_arithmetique()
| 	Terme_record() (<OpenParen> <Quote > <IDENTIFIER> <CloseParen>)*
} 

void Terme_simple() #TermeSimple : {} {
	Ident_ren() (<OpenParen> <Quote > <IDENTIFIER> <CloseParen>)*
| 	Entier_lit()
| 	Boolean_lit()
| 	<Boolean> <OpenParen> Condition() <CloseParen>
}

void Entier_lit() #Entier_Lit : {} {
	<Number>
| 	<MaxInt>
| 	<MinInt>
}

void Boolean_lit() #Boolean_Lit : {} {
	<False>
| 	<True>
}

void Terme_record() #Terme_record : {} {
	< Rec > <OpenParen > [<IDENTIFIER > <In >] (Terme() | Expr_tableau()) (< Comma > [<IDENTIFIER > <In >](Terme() | Expr_tableau()))* < CloseParen >
}

void Expr_tableau() #Expr_tableau : {} {
	< IDENTIFIER > 
| 	< OpenBraces > Terme_simple() (< Maplet > Terme_simple())* < Maplet > Terme() ( < Comma > Terme_simple() (< Maplet > Terme_simple())* < Maplet > Terme())* < CloseBraces >
| 	Ensemble_simple() (< Product > Ensemble_simple()) < Product > <OpenBraces > Terme() < CloseBraces >
}

void Condition() #Condition : { } {
	Terme_simple() (< Equal > #Equal |  < NotEqual > #NotEqual |  < LessThan > #LessThan |  < GreatherThan > #GreatherThan |  < LessThanOrEqual > #LessThanOrEqual |< GreatherThanOrEqual > #GreatherThanOrEqual)	Terme_simple() CondBis()
| 	< Not > #Not Condition() CondBis()
|   < OpenParen > Condition() < CloseParen > CondBis()
}

void CondBis() : { } {
	< And > #And(2) Condition() CondBis()
| 	< Or > #Or(2) Condition() CondBis()
|   {}
}

void Instruction() #Instruction: {} {
	Instruction_bloc()
| 	Instruction_variable_locale()
| 	Substitution_identite()
| 	Instruction_devient_egal()
| 	Instruction_appel_operation()
| 	Instruction_conditionnelle()
| 	Instruction_cas()
| 	Instruction_assertion()
| 	Instruction_sequence()
| 	Substitution_tant_que()
}

void Instruction_corps_operation() #Instruction_corps_operation: {} {
	Instruction_bloc()
| 	Instruction_variable_locale()
| 	Substitution_identite()
| 	Instruction_devient_egal()
| 	Instruction_appel_operation()
| 	Instruction_conditionnelle()
| 	Instruction_cas()
| 	Instruction_assertion()
| 	Substitution_tant_que()
}

void Instruction_bloc() #Instruction_bloc : {} {
	< Begin > Instruction() < End > 
}

void Instruction_variable_locale() #Instruciton_variable_locale : { } {
	< Var > < IDENTIFIER > (< Comma > < IDENTIFIER > )* < In > Instruction() < End > 
}

void Instruction_devient_egal() #Instruction_devient_egal : {} {
	Ident_ren()
	(
	   [< OpenParen > Terme() (< Comma > Terme())* < CloseParen >] < DevientEgal > Terme()
		| < DevientEgal > Expr_tableau()
		| < Quote > < IDENTIFIER > ( < Quote > < IDENTIFIER > )* < DevientEgal > Terme()
	)
}

void Instruction_appel_operation() #Instruction_appel_operation : {} {
	[Ident_ren() (< Comma > Ident_ren())* < OperationReturn >] Ident_ren() [< OpenParen > (Terme() | < String >) (< Comma > (Terme() | < String >))* < CloseParen > ]  
}

void Instruction_sequence() #Instruction_sequence : {} { 
	Instruction_bloc() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_variable_locale() < SemiColon > Instruction() InstrSeqBis() 
| 	Substitution_identite() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_devient_egal() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_appel_operation() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_conditionnelle() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_cas() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_assertion() < SemiColon > Instruction() InstrSeqBis() 
| 	Substitution_tant_que() < SemiColon > Instruction() InstrSeqBis() 
}

void InstrSeqBis()  : {} {
	< SemiColon > Instruction() InstrSeqBis()
|	{}
}

void Instruction_conditionnelle() #Instruction_conditionnelle : {} {
	< If > Condition() < Then > Instruction() (< Elsif > Condition() < Then > Instruction())* [< Else > Instruction() ] < End >   
}

void Instruction_cas() #Instruction_cas : {} {
	< Case > Terme_simple() < Of > < Either > Terme_simple() (< Comma > Terme_simple() )* < Then > Instruction()
	( < Or > Terme_simple() (< Comma > Terme_simple() )* < Then > Instruction())*
	[< Else > Instruction() ]
	< End > < End > 
}

void Substitution_tant_que() #Substitution_tant_que : {} {
	< While > Condition() < Do > Instruction() < Invariant > Predicat() < Variant > Expression() < End >   
}

void Instruction_assertion() #Instruction_assertion : {} {
	< Assert > Condition() < Then > Instruction() < End > 
}

void Predicat() #predicat(>1) : {} {
	Predicat_Parenthese() PredicatBis() 
| 	Predicat_Negation() PredicatBis() 
| 	Predicat_Universel() PredicatBis() 
| 	Predicat_Existentiel() PredicatBis() 
| 	Predicat_Egalite() PredicatBis() 
| 	Predicat_Inegalite() PredicatBis() 
| 	Predicat_Appartenance() PredicatBis() 
| 	Predicat_Non_Appartenance() PredicatBis() 
| 	Predicat_Inclusion() PredicatBis() 
| 	Predicat_Inclusion_Stricte() PredicatBis() 
| 	Predicat_Non_Inclusion() PredicatBis() 
| 	Predicat_Non_Inclusion_Stricte() PredicatBis() 
| 	Predicat_Inferieur_Ou_Egal() PredicatBis() 
| 	Predicat_Strictement_Inferieur() PredicatBis() 
| 	Predicat_Superieur_Ou_Egal() PredicatBis() 
| 	Predicat_Strictement_Superieur()  PredicatBis() 
}

void PredicatBis() : { } {
	< And > #And(2) Predicat() PredicatBis() 
| 	< Union > #Union(2) Predicat() PredicatBis() 
| 	< Implication > #Implication(2) Predicat() PredicatBis() 
| 	< Equivalence > #Equivalence(2) Predicat() PredicatBis() 
| { }
}

void  Predicat_Parenthese() #Predicat_parenthese(1) : {}{
< OpenParen > Predicat() < CloseParen > 
}

void  Predicat_Negation() #Predicat_Negation(1) : {}{
< Not > < OpenParen > Predicat() < CloseParen > 
}

void  Predicat_Universel() #Predicat_Universel(3) : {}{
 < Forall > Liste_ident() < Point > < OpenParen > Predicat() < Implication > Predicat() < CloseParen >
}

void  Predicat_Existentiel() #Predicat_Existentiel(2) : {}{
 < Exists >  Liste_ident() < Point > < OpenParen > Predicat() < CloseParen >
}

void  Predicat_Egalite() #Predicat_Egalite(2) : {}{
	Expression() < Equal > Expression()
}

void  Predicat_Inegalite() #Predicat_Inegalite(2) : {}{
 Expression() < NotEqual >  Expression()
}

void  Predicat_Appartenance() #Predicat_Appartenance(2) : {}{
 Expression() < In > Expression()
}

void  Predicat_Non_Appartenance() #Predicat_Not_Appartenance(2) : {}{
 Expression() < NotSetMemberShip >  Expression()
}

void  Predicat_Inclusion() #Predicat_Inclusion(2) : {}{
 Expression() < Subset >  Expression()
}

void  Predicat_Inclusion_Stricte() #Predicat_Insclusion_Stricte(2) : {}{
 Expression() < StrictSubset >  Expression()
}

void  Predicat_Non_Inclusion() #Predicat_Non_Inclusion(2) : {}{
 Expression() < NotSubset >  Expression()
}

void  Predicat_Non_Inclusion_Stricte() #Predicat_Non_Inclusion_Stricte(2) : {}{
 Expression() < NotStrictSubset >  Expression()
}

void  Predicat_Inferieur_Ou_Egal() #Predicat_Inferieur_Ou_Egal(2) : {}{
 Expression() < LessThanOrEqual >  Expression()
}

void  Predicat_Strictement_Inferieur() #Predicat_Strictement_Inferieur(2) : {}{
 Expression() < LessThan >  Expression()
}

void  Predicat_Strictement_Superieur() #Predicat_Strictement_Superieur(2) : {}{
 Expression() < GreatherThan >  Expression()
}

void  Predicat_Superieur_Ou_Egal() #Predicat_Superieur_Ou_Egal(2) : {}{
 Expression() < GreatherThanOrEqual >  Expression()
}

void Expression() #Expression(1) : { } {
   	Expression_primaire() ExpressionBis()
|   Expression_booleenne() ExpressionBis()
|   Expression_arithmetique() ExpressionBis()
| 	Construction_d_ensembles() ExpressionBis()
|	Expression_d_ensembles() ExpressionBis()
|   Expression_de_relations() ExpressionBis()
|   Construction_de_fonctions() ExpressionBis()
}

void ExpressionBis() : { } {
  ( < PartialFunction > #Fonction_partielle |< TotalFunction > #Fonction_totale | < PartialInjection > #Injection_partielle | < TotalInjection > #Injection_totale | < PartialSurjection > #Surjection_partielle | < TotalSurjection > #Surjection_totale | < TotalBijection > #Bijection_totale |< Maplet >#Couple|< Comma > #Couple) Expression() ExpressionBis()
| {}
}   

void Expression_primaire () #Expression_primaire : {Token t; } {
	Donnee()
| 	Expr_parenthesee()
}

void Expression_booleenne () #Expression_booleenne : { } {
	Boolean_lit() 
| 	Conversion_bool() 
}


void Expression_arithmetique() #ExprArith : {} {
	Entier_lit() ExpArithBis() 
| 	Ident_ren() 
[
	(<OpenParen > Terme() (<Comma> Terme())* <CloseParen>)
	| (< Quote > <IDENTIFIER> (< Quote > <IDENTIFIER>)*)
]  ExpArithBis() 
|	< Minus > #MoinsUnaire Expression_arithmetique() ExpArithBis() 
|  	< Succ > #Successeur <OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis() 
|  	< Pred > #Predecesseur <OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis() 
|	< OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis()
| 	< Max > #Maximum < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Min > #Minimum < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Card > #Cardinal < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Sigma > #Somme_generalisee Liste_ident() < Point > < OpenParen > Predicat() < SuchAs > Expression() < CloseParen > ExpArithBis()
| 	< Pi > #Produit_generalisee Liste_ident() < Point > < OpenParen > Predicat() < SuchAs > Expression() < CloseParen > ExpArithBis()
}

void ExpArithBis() : {} {
	< Plus > #Addition Expression_arithmetique()  ExpArithBis() 
| 	< Minus > #Soustraction Expression_arithmetique()  ExpArithBis() 
| 	< Product > #Producion Expression_arithmetique()  ExpArithBis() 
| 	< Division > #Division Expression_arithmetique() ExpArithBis() 
| 	< Modulo > #Modulo Expression_arithmetique()  ExpArithBis() 
| 	< Power > #Puissance Expression_arithmetique()  ExpArithBis()
|   {}
}

void Expression_d_ensembles() #Expression_d_ensembles : {} {
	Ensemble_vide()
|   Ensemble_entier()
|   Ensemble_booleen()
|   Ensemble_chaines()
}


void Construction_d_ensembles() #Construction_d_ensembles : {} {
    <OpenBraces> ( (< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > #EnsComprehension Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis()
|   Sous_ensembles() ConstrEnsembleBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis()
| 	< UnionGen > #Union_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis()
| 	< InterGen > #Intersection_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis()
| 	< UnionQuant > #Union_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis()
| 	< InterQuant > #Intersection_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis()
| 	Expression_primaire() ExpressionBis() (< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis()
|   Expression_booleenne() ExpressionBis() (< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis()
|   Expression_arithmetique() ExpressionBis() (< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis()
|   Expression_d_ensembles() ExpressionBis() (< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis()
|   Expression_de_relations() ExpressionBis() (< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis()
|   Construction_de_fonctions() ExpressionBis() (< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis()
}
void ConstrEnsembleBis() : { } {
	ExpressionBis() (< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis()
| 	{ }
}

void Construction_de_fonctions() #Construction_de_fonctions : {} {
	< Lambda > #Lambda_expression Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrFonctionBis()
|   < OpenBraces >  ((< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > #Ens_comprehension Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< UnionGen > #Union_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< InterGen > #Intersection_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< UnionQuant > #Union_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< InterQuant > #Intersection_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< Fnc > #Transformee_fonction < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< Rel > #Transformee_relation < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
|   Sous_ensembles() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
|	Expression_primaire() ExpressionBis() ((< OpenParen >  Expression() < CloseParen > ) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_booleenne() ExpressionBis() ((< OpenParen > #Evaluation_fonction Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_arithmetique() ExpressionBis() ((< OpenParen > #Evaluation_fonction Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_d_ensembles() ExpressionBis() ((< OpenParen > #Evaluation_fonction Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_de_relations() ExpressionBis() ((< OpenParen > #Evaluation_fonction Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
}

void ConstrFonctionBis() : { } {
	ExpressionBis() ((< OpenParen > #Evaluation_fonction Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
| 	{ }
}
void Expression_de_relations() #Expression_de_relations : {} {
	< Id > #Identite < OpenParen >  Expression() < CloseParen > ExprRelationBis() 
| 	< Prj1 > #Premiere_projection < OpenParen > Expression() < Comma > Expression() < CloseParen > ExprRelationBis()
| 	< Prj2 > #Deuxieme_projection < OpenParen > Expression() < Comma > Expression() < CloseParen > ExprRelationBis()
| 	< Dom > #Domaine < OpenParen >  Expression() < CloseParen > ExprRelationBis()
| 	< Ran > #Codomaine < OpenParen >  Expression() < CloseParen > ExprRelationBis()
|   <OpenBraces> ( (< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > #Ens_comprehension Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
|   Sous_ensembles() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
|   Sous_ensembles() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< UnionGen > #Union_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< InterGen > #Intersection_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< UnionQuant > #Union_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< InterQuant > #Intersection_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< Lambda > #Lambda_expression Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
|   <OpenBraces> ((< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< UnionGen > #Union_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< InterGen > #Intersection_generalisee < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< UnionQuant > #Union_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< InterQuant > #Intersection_quantifiee Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< Fnc > #Transformee_fonction < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< Rel > #Transformee_relation < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	Expression_primaire() ExpressionBis() (((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen > ) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
|   Expression_booleenne() ExpressionBis() (((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
|   Expression_arithmetique() ExpressionBis() (((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
|   Expression_d_ensembles() ExpressionBis() (((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
}

void ExprRelationBis() : { } {
	ExpressionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (Expression_de_relations() ExpressionBis() ((< OpenParen > #Evaluation_fonction Expression() < CloseParen >) | ((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > #Produit_ensemble | < NatRange > #Intervalle(2) | < Minus > #Soustraction | < Union > #Union |< Intersection > #Intersection ) Expression() ConstrEnsembleBis() (( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > #EnsembleRelation | < SemiColon > #Composition | < DirectProduct > #Produit_direct | < Parallel > #Produit_parallele | < Power > #Puissance | < DomainRestriction > #Restriction_domaine| < DomainSubstraction > #Soustractions_domaine | < RangeRestriction > #Restriction_codomaine | < RangeSubstraction > #Soustractions_codomaine | < Override > #Surcharge ) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
| { }
}

void Expr_parenthesee() #Expr_parenthesee : {} {
	< OpenParen > Expression() < CloseParen >
}

void Conversion_bool() #Conversion_bool : {} {
	< Bool > < OpenParen > Predicat() < CloseParen >
}

void Ensemble_vide() #Ensemble_vide : {} {
	< EmptySet > 
}

void Ensemble_entier() #Ensemble_entier : {} {
	< Nat >
| 	< Nat1 >
| 	< Natural >
| 	< Natural1 >
| 	< Int >
| 	< Integer >  
}

void Ensemble_chaines() #Ensemble_chaines : {} {
	< String >
}

void Ensemble_booleen() #Ensemble_booleen : {} {
	< Bool >
}

void Sous_ensembles() #Sous_ensembles : {} {
	< POW > < OpenParen >  Expression() < CloseParen >
|	< POW1 > < OpenParen >  Expression() < CloseParen >
}

void Sous_ensembles_finis() #Sous_ensembles_finis : {} {
    < FIN > < OpenParen >  Expression() < CloseParen >
|   < FIN1 > < OpenParen >  Expression() < CloseParen >
}

void Substitution() #Substitution(>1) : {} {
	Substitution_bloc() SubstitutionBis() 
|	Substitution_identite() SubstitutionBis() 
|	Substitution_devient_egal() SubstitutionBis() 
|	Substitution_precondition() SubstitutionBis() 
|	Substitution_assertion() SubstitutionBis() 
|	Substitution_choix_borne() SubstitutionBis() 
|	Substitution_conditionnelle() SubstitutionBis() 
|	Substitution_selection() SubstitutionBis() 
|	Substitution_cas() SubstitutionBis() 
|	Substitution_choix_non_borne() SubstitutionBis() 
|	Substitution_definition_locale() SubstitutionBis() 
|	Substitution_devient_elt_de() SubstitutionBis() 
|	Substitution_devient_tel_que() SubstitutionBis() 
|	Substitution_variable_locale() SubstitutionBis() 
|	Substitution_appel_operation()  SubstitutionBis() 
|	Substitution_tant_que()  SubstitutionBis() 
}

void SubstitutionBis() : { } {
 	< SemiColon > #Substitution_sequence Substitution() SubstitutionBis() 
|	< Parallel > #Substitution_simultanee Substitution() SubstitutionBis() 
| { }	
}

void Substitution_corps_operation() #Substitution_corps_operation(>1) : {} {
	Substitution_bloc()
|	Substitution_identite()
|	Substitution_devient_egal()
|	Substitution_precondition()
|	Substitution_assertion()
|	Substitution_choix_borne()
|	Substitution_conditionnelle()
|	Substitution_selection()
|	Substitution_cas()
|	Substitution_choix_non_borne()
|	Substitution_definition_locale()
|	Substitution_devient_elt_de()
|	Substitution_devient_tel_que()
|	Substitution_variable_locale()
|	Substitution_appel_operation()
}

void Substitution_bloc() #Substitution_bloc : {} {
	< Begin > Substitution() < End >
}

void Substitution_identite() #Substitution_identite : {} {
	< Skip >
}

void Substitution_devient_egal() #Substitution_devient_egal : {} {
	Ident_ren()
	(
	  (< Comma > Ident_ren())* < DevientEgal > Expression() (< Comma > Expression())*
		|	< OpenParen > Expression() (< Comma > Expression())* < CloseParen > < DevientEgal > Expression()
		|	< Quote > < IDENTIFIER > (< Quote > < IDENTIFIER >)* < DevientEgal > Expression()
	)
}

void Substitution_precondition() #Substitution_precondition : {} {
	< Pre > Predicat() < Then > Substitution() < End >
}

void Substitution_assertion() #Substitution_assertion : {} {
	< Assert > Predicat() < Then > Substitution() < End >
}

void Substitution_choix_borne() #Substitution_choix_borne : {} {
	< Choice > Substitution() ( < OrC > Substitution() )* < End >
}

void Substitution_conditionnelle() #Substitution_conditionnelle : {} {
	< If > Predicat() < Then > Substitution()
	( < Elsif > Predicat() < Then > Substitution() )*
	[ < Else > Substitution() ]
	< End >
}

void Substitution_selection() #Substitution_selection : {} {
	< Select > Predicat() < Then > Substitution()
	( < When > Predicat() < Then > Substitution() )*
	[ < Else > Substitution()]
	< End >
}

void Substitution_cas() #Substitution_cas : {} {
	< Case > Expression() < Of >
	< Either > Terme_simple() (< Comma > Terme_simple())* < Then > Substitution()
	( < OrC > Terme_simple() (< Comma > Terme_simple())* < Then > Substitution() )*
	[ < Else > Substitution() ]
	< End >
	< End >
}

void Substitution_choix_non_borne() #Substitution_choix_non_borne : {} {
	< Any > < IDENTIFIER > (< Comma > < IDENTIFIER >)* < Where > Predicat() < Then > Substitution() < End >
}

void Substitution_definition_locale() #Substitution_definition_locale : {} {
	< Let > < IDENTIFIER > (< Comma > < IDENTIFIER >)* < Be >
	< IDENTIFIER > < Equal > Expression() ( < ConcatSequence > < IDENTIFIER > < Equal > Expression() )*
	< InLetVar > Substitution() < End >
}

void Substitution_devient_elt_de() #Substitution_devient_elt_de : {} {
	Ident_ren()(< Comma > < IDENTIFIER >)* < SetIn > Expression()
}

void Substitution_devient_tel_que() #Substitution_devient_tel_que : {} {
	Ident_ren()(< Comma > Ident_ren())* < In > < OpenParen > Predicat() < CloseParen >
}

void Substitution_variable_locale() #Substitution_variable_locale : {} {
	< Var > < IDENTIFIER >(< Comma > Ident_ren())* < InLetVar > Substitution() < End >
}

void Substitution_appel_operation() #Substitution_appel_operation : {} {
	[ Ident_ren()(< Comma > Ident_ren())* < OperationReturn > ] Ident_ren() [ < OpenParen > Expression()(< Comma > Expression())* < CloseParen > ]
}

void Liste_ident() #Liste_ident : {} {  
	< IDENTIFIER >
| 	< OpenParen > < IDENTIFIER >  (< Comma > < IDENTIFIER >)* < CloseParen >
}

void Ensemble_simple() #Ensemble_simple : { } { 
	< Bool > 
| 	< IDENTIFIER > 
}