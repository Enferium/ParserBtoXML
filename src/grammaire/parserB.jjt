options {
	STATIC = false;
	VISITOR=true;
	VISITOR_EXCEPTION = "ParserBException";
	NODE_DEFAULT_VOID=true;
	MULTI = true;
}


PARSER_BEGIN(ParserB)

package grammaire ;

import java.io.*;
import java.util.*;

public class ParserB {


}

PARSER_END(ParserB)


SKIP : {
  < [" ", "\t", "\n", "\r", "\u00a0"] >
}

SKIP : {
	"/*" : WithinComment
}

<WithinComment> SKIP : {
	"*/" : DEFAULT
}

<WithinComment> MORE:
{
  < ~[] >
}

TOKEN : {

  	<Machine: "MACHINE">
|  	<End : "END">
|  	<Sets : "SETS">
|  	<Invariant : "INVARIANT">
|  	<Assert : "ASSERT">
|  	<Variables : "VARIABLES">
|  	<Operations : "OPERATIONS">
| 	<Events : "EVENTS">
|	<Constraints : "CONSTRAINTS">
|	<Constants : "CONSTANTS">
|	<Properties : "PROPERTIES">
|	<ConcreteVariables : "CONCRETE_VARIABLES">
|	<AbstractVariables : "ABSTRACT_VARIABLES">
|	<ConcreteConstants : "CONCRETE_CONSTANTS">
|	<AbstractConstants : "ABSTRACT_CONSTANTS">
|	<Initialisation : "INITIALISATION" >
|	<Definitions : "DEFINITIONS">
|	<Values : "VALUES">
|	<Begin : "BEGIN">
|	<Pre : "PRE">
|	<If : "IF">
|	<Then : "THEN">
|	<Elsif : "ELSIF">
|	<Else : "ELSE">
|	<Any : "ANY">
|	<Where : "WHERE">
|	<Let : "LET">
|	<Be : "BE">
|	<InLetVar : "IN">
|	<Choice : "CHOICE">
|	<OrC : "OR">
|	<Select : "SELECT">
|	<When : "WHEN">
|	<Case : "CASE">
|	<Of : "OF">
|	<Either : "EITHER">
|	<Var : "VAR">
|	<While : "WHILE">
|	<Do : "DO">
|	<Variant : "VARIANT">

|	<EmptySet : "{" (" ")* "}">
|	<EmptySequence : "[" (" ")* "]">
|	<EmptySequenceOld : "<>">


|	<Equivalence : "<=>">
|	<Subset : "<:">
|	<NotSubset : "/<:">
|	<Implication : "=>">
|	<StrictSubset : "<<:">
|	<NotStrictSubset : "/<<:">
|	<NotSetMemberShip : "/:">
|	<NotEqual : "/=">

|	<LessThanOrEqual : "<=">
|	<GreatherThanOrEqual : ">=">


|	<Relation : "<->">
|	<PartialSurjection : "+->>">
|	<PartialFunction: "+->">
|	<TotalSurjection : "-->>">
|	<TotalFunction : "-->">
|	<PartialBijection : ">+>>">
|	<PartialInjection : ">+>">
|	<TotalBijection : ">->>">
|	<TotalInjection : ">->">

|	<OperationReturn : "<--">
|	<DevientEgal : ":=">

|	<OpenCurly : "[">
|	<CloseCurly : "]">

|	<Maplet : "|->">

|	<DomainSubstraction : "<<|">
|	<DomainRestriction : "<|">
|	<RangeSubstraction : "|>>">
|	<RangeRestriction : "|>">
|	<Override : "<+">
|	<DirectProduct : "><">
|	<PrependSequence : "->">
|	<AppendSequence : "<-">
|	<PrefixSequence : "/|\\">
|	<SuffixSequence : "\\|/">

|	<SetIn : "::">
|	<EqualEqual : "==">
|	<NatRange : "..">
|	<Power : "**">

|	<Union : "\\/">
|	<Intersection : "/\\">

|	<Lambda : "%">
|	<SuchAs : "|">
|	<Forall : "!">
|	<Exists : "#">
|	<Tilde : "~">
|	<OpenBraces : "{">
|	<CloseBraces : "}">
|  	<Point : ".">
|  	<OpenParen : "(">
|  	<CloseParen : ")">
|	<Comma : ",">
|	<Or : "or">
|	<And  : "&">
|	<Not : "not">
|	<Skip : "skip">
|	<Minus : "-">
|	<Plus : "+">
|	<Product : "*">
|	<Division : "/">
|	<Modulo : "mod">
|	<Equal : "=">
|	<ConcatSequence : "^">
|	<LessThan : "<">
|	<GreatherThan : ">">

|	<In : ":">
|	<DollarZero : "$0">

| 	<Composition : "Â°">
|	<ParallelProduct : "//">
|	<SetMinus : "\\">

|	<Parallel : "||">
|	<SemiColon : ";">
|	<Quote : "'">

|	<Prj1 : "prj1">
|	<Prj2 : "prj2">
|	<POW : "POW">
|	<FIN : "FIN">
|	<POW1 : "POW1">
|	<FIN1 : "FIN1">
|	<InterGen : "inter">
|	<UnionGen : "union">
|	<UnionQuant : "UNION">
|	<InterQuant : "INTER">
|	<Id : "id">
|	<Dom : "dom">
|	<Ran : "ran">
|	<Iterate : "iterate">
|	<Closure : "closure">
|	<Closure1 : "closure1">
|	<Card : "card">
|	<Max : "max">
|	<Min : "min">
|   <Succ : "succ">
|	<Pred : "pred">
|	<Sigma : "SIGMA">
|	<Pi : "PI">
|	<Seq : "seq">
|	<Iseq : "iseq">
|	<Seq1 : "seq1">
|	<Iseq1 : "iseq1">
|	<Perm : "perm">
|	<Conc : "conc">
|	<Front : "front">
|	<Tail : "tail">
|	<First : "first">
|	<Last : "last">
|	<Size : "size">
|	<Rev : "rev">
|	<Fnc : "fnc">
|	<Rel : "rel">
|	<Rec : "rec">
|	<Struct : "struct">
|	<Bool : "bool">

|	<Nat : "NAT">
|	<Nat1 : "NAT1">
|	<Natural : "NATURAL">
|	<Natural1 : "NATURAL1">
|	<Int : "INT">
|	<Integer : "INTEGER">
|	<True : "TRUE">
|	<False : "FALSE">
|	<Boolean : "BOOL">
|	<StringSet : "STRING">
|	<MaxInt : "MAXINT">
|	<MinInt : "MININT">

| 	<Tree : "tree" >
| 	<Btree : "btree" >
| 	<Const : "const" > 
| 	<Top : "top" >
| 	<Sons : "sons" >
| 	< Prefix : "prefix"> 
| 	< Postfix : "postfix"> 
| 	< Sizet : "sizet" >
| 	< Mirror : "mirror" >
| 	< Rank : "rank" >
| 	< Father : "father" >
| 	< Son : "son" >
| 	< Subtree : "subtree" >
| 	< Arity : "arity" >
| 	< Bin : "bin" >
| 	< Left : "left" >
| 	< Right : "right" >
| 	< Infix : "infix" >
}

TOKEN : {
	<IDENTIFIER : ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_","0"-"9"])*>
}

TOKEN : {
	<String:
      		"\""
      		(         (~["\"","\\","\n","\r"])
        		| ("\\"
            			(   ["n","t","b","r","f","\\","'","\""]
            			  | ["0"-"7"] ( ["0"-"7"] )?
            			  | ["0"-"3"] ["0"-"7"] ["0"-"7"]
           			)
          		  )
      		)*
          	"\""
  	>
}

TOKEN : {
	<Number : (["0"-"9"])+ >
}

ASTStart Start() #Start : {} {
  Composant()
  { return jjtThis; }
}

void Donnee() : { } {
	Ident_ren()
}

void Ident_ren() #Ident_ren : {} {
   < IDENTIFIER > (< Point > < IDENTIFIER > )*
}

void Composant() : {} {
   Machine_abstraite ()
}

void Machine_abstraite () #Machine : {} {
	<Machine> EnTete() (Clause_machine_abstraite())* <End>
}

void Clause_machine_abstraite() : {} {
	Clause_constraints()
	|  Clause_sets()
	|  Clause_concrete_constants()
	|  Clause_abstract_constants()
	|  Clause_properties()
	|  Clause_concrete_variables()
	|  Clause_abstract_variables()
	|  Clause_invariant()
	|  Clause_initialisation()
	|  Clause_operations()
}

void EnTete() #EnTete : {} {
	<IDENTIFIER> [<OpenParen> <IDENTIFIER>(<Comma> <IDENTIFIER>)* <CloseParen>]
}

void Clause_constraints () #Constraints : {} {
	<Constraints> Predicat()
}

void Instanciation() : {} {
		Terme()
	|   Ensemble_entier() 
	|  	<Boolean>
	|  	Intervalle()
}

void Clause_sets () #Sets : {} {
	<Sets> Ensemble() (<SemiColon> Ensemble())*
}

void Ensemble() #Ensemble : {} {
  <IDENTIFIER> [<Equal> <OpenBraces> <IDENTIFIER> (<Comma> <IDENTIFIER>)*  <CloseBraces>]
}

void Clause_concrete_constants() #ConcreteConstants : {} {
	(<ConcreteConstants> | <Constants> ) <IDENTIFIER> (<Comma> <IDENTIFIER>)*
}

void Clause_abstract_constants() #AbstractConstants : {} {
	<AbstractConstants> <IDENTIFIER> (<Comma> <IDENTIFIER>)*
}

void Clause_properties() #Properties : {} {
	<Properties> Predicat()
}

void Clause_values() #Values : {} {
	<Values> Valuation() (<SemiColon> Valuation())*
}

void Valuation() #Value : {} {
	< IDENTIFIER > <Equal> (Terme() | Expr_tableau())
}

void Clause_concrete_variables() #ConcreteVariables : {} {
	<ConcreteVariables> Ident_ren() (<Comma> Ident_ren())*
}

void Clause_abstract_variables() #AbstractVariables : {} {
	(<AbstractVariables> | <Variables>) Ident_ren() (<Comma> Ident_ren())*
}

void Clause_invariant() #Invariant : {} {
	<Invariant> Predicat()
}

void Clause_initialisation() #Initialisation : {} {
	<Initialisation> Substitution()
}

void Clause_operations() #Operations  : {} {
	<Operations> Operation() (<SemiColon> Operation())*
}

void Operation() #Operation : {} {
	Entete_operation() <Equal> Substitution_corps_operation()
}

void Entete_operation() #EnteteOperation : {} {
	[<IDENTIFIER> (<SemiColon> <IDENTIFIER>)* <OperationReturn> ] Ident_ren()
	 [<OpenParen> <IDENTIFIER>(<Comma> <IDENTIFIER>)* <CloseParen>]
}

void Terme() #Terme : {} {
	Terme_simple()
| 	Expression_arithmetique()
| 	Terme_record() (<OpenParen> <Quote > <IDENTIFIER> <CloseParen>)*
} 

void Terme_simple() #TermeSimple : {} {
	Ident_ren() (<OpenParen> <Quote > <IDENTIFIER> <CloseParen>)*
| 	Entier_lit()
| 	Boolean_lit()
| 	<Boolean> <OpenParen> Condition() <CloseParen>
}

void Entier_lit() #Entier_Lit : {} {
	<Number>
| 	<MaxInt>
| 	<MinInt>
}

void Boolean_lit() #Boolean_Lit : {} {
	<False>
| 	<True>
}

void Terme_record() #Terme_record : {} {
	< Rec > <OpenParen > [<IDENTIFIER > <In >] (Terme() | Expr_tableau()) (< Comma > [<IDENTIFIER > <In >](Terme() | Expr_tableau()))* < CloseParen >
}

void Expr_tableau() #Expr_tableau : {} {
	< IDENTIFIER > 
| 	< OpenBraces > Terme_simple() (< Maplet > Terme_simple())* < Maplet > Terme() ( < Comma > Terme_simple() (< Maplet > Terme_simple())* < Maplet > Terme())* < CloseBraces >
| 	Ensemble_simple() (< Product > Ensemble_simple()) < Product > <OpenBraces > Terme() < CloseBraces >
}

void Condition() #Condition : { } {
	Terme_simple() (< Equal > |  < NotEqual > |  < LessThan > |  < GreatherThan > |  < LessThanOrEqual > |< GreatherThanOrEqual >)	Terme_simple() CondBis()
| 	< Not > Condition() CondBis()
|   < OpenParen > Condition() < CloseParen > CondBis()
}

void CondBis() : { } {
	< And > Condition() CondBis()
| 	< Or > Condition() CondBis()
|   {}
}

void Instruction() #Instruction: {} {
	Instruction_bloc()
| 	Instruction_variable_locale()
| 	Substitution_identite()
| 	Instruction_devient_egal()
| 	Instruction_appel_operation()
| 	Instruction_conditionnelle()
| 	Instruction_cas()
| 	Instruction_assertion()
| 	Instruction_sequence()
| 	Substitution_tant_que()
}

void Instruction_corps_operation() #Instruction_corps_operation: {} {
	Instruction_bloc()
| 	Instruction_variable_locale()
| 	Substitution_identite()
| 	Instruction_devient_egal()
| 	Instruction_appel_operation()
| 	Instruction_conditionnelle()
| 	Instruction_cas()
| 	Instruction_assertion()
| 	Substitution_tant_que()
}

void Instruction_bloc() #Instruction_bloc : {} {
	< Begin > Instruction() < End > 
}

void Instruction_variable_locale() #Instruciton_variable_locale : { } {
	< Var > < IDENTIFIER > (< Comma > < IDENTIFIER > )* < In > Instruction() < End > 
}

void Instruction_devient_egal() #Instruction_devient_egal : {} {
	Ident_ren() [< OpenParen > Terme() (< Comma > Terme())* < CloseParen >] < DevientEgal > Terme()
| 	Ident_ren() < DevientEgal > Expr_tableau()
|  	Ident_ren() < Quote > < IDENTIFIER > ( < Quote > < IDENTIFIER > )* < DevientEgal > Terme()  
}

void Instruction_appel_operation() #Instruction_appel_operation : {} {
	[Ident_ren() (< Comma > Ident_ren())* < OperationReturn >] Ident_ren() [< OpenParen > (Terme() | < String >) (< Comma > (Terme() | < String >))* < CloseParen > ]  
}

void Instruction_sequence() #Instruction_sequence : {} { 
	Instruction_bloc() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_variable_locale() < SemiColon > Instruction() InstrSeqBis() 
| 	Substitution_identite() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_devient_egal() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_appel_operation() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_conditionnelle() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_cas() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_assertion() < SemiColon > Instruction() InstrSeqBis() 
| 	Substitution_tant_que() < SemiColon > Instruction() InstrSeqBis() 
}

void InstrSeqBis()  : {} {
	< SemiColon > Instruction() InstrSeqBis()
|	{}
}

void Instruction_conditionnelle() #Instruction_conditionnelle : {} {
	< If > Condition() < Then > Instruction() (< Elsif > Condition() < Then > Instruction())* [< Else > Instruction() ] < End >   
}

void Instruction_cas() #Instruction_cas : {} {
	< Case > Terme_simple() < Of > < Either > Terme_simple() (< Comma > Terme_simple() )* < Then > Instruction()
	( < Or > Terme_simple() (< Comma > Terme_simple() )* < Then > Instruction())*
	[< Else > Instruction() ]
	< End > < End > 
}

void Substitution_tant_que() #Substitution_tant_que : {} {
	< While > Condition() < Do > Instruction() < Invariant > Predicat() < Variant > Expression() < End >   
}

void Instruction_assertion() #Instruction_assertion : {} {
	< Assert > Condition() < Then > Instruction() < End > 
}

void Predicat() #predicat : {} {
	Predicat_Parenthese()
| 	Predicat_Conjonction()
| 	Predicat_Negation()
| 	Predicat_Disjonction()
|	Predicat_Implication()
| 	Predicat_Equivalence()
| 	Predicat_Universel()
| 	Predicat_Existentiel()
| 	Predicat_Egalite()
| 	Predicat_Inegalite()
| 	Predicat_Appartenance()
| 	Predicat_Non_Appartenance()
| 	Predicat_Inclusion()
| 	Predicat_Inclusion_Stricte()
| 	Predicat_Non_Inclusion()
| 	Predicat_Non_Inclusion_Stricte()
| 	Predicat_Inferieur_Ou_Egal()
| 	Predicat_Strictement_Inferieur()
| 	Predicat_Superieur_Ou_Egal()
| 	Predicat_Strictement_Superieur()
}

void  Predicat_Parenthese() #Predicat_parenthese : {}{
< OpenParen > Predicat() < CloseParen > 
}

void  Predicat_Conjonction() #Predicat_Conjonction : {}{
 Predicat() < And > Predicat() 
}

void  Predicat_Negation() #Predicat_Negation : {}{
< Not > < OpenParen > Predicat() < CloseParen > 
}

void  Predicat_Disjonction() #Predicat_Disjonction : {}{
 Predicat() < Union > Predicat() 
}

void  Predicat_Implication() #Predicat_Implication : {}{
 Predicat() < Implication >  Predicat() 
}

void  Predicat_Equivalence() #Predicat_Equivalence : {}{
 Predicat() < Equivalence >  Predicat() 
}

void  Predicat_Universel() #Predicat_Universel : {}{
 < Forall > Liste_ident() < Point > < OpenParen > Predicat() < Implication > Predicat() < CloseParen >
}

void  Predicat_Existentiel() #Predicat_Existentiel : {}{
 < Exists >  Liste_ident() < Point > < OpenParen > Predicat() < CloseParen >
}

void  Predicat_Egalite() #Predicat_Egalite : {}{
 Expression() < Equal > Expression()
}

void  Predicat_Inegalite() #Predicat_Inegalite : {}{
 Expression() < NotEqual >  Expression()
}

void  Predicat_Appartenance() #Predicat_Appartenance : {}{
 Expression() < In > Expression()
}

void  Predicat_Non_Appartenance() #Predicat_Not_Appartenance : {}{
 Expression() < NotSetMemberShip >  Expression()
}

void  Predicat_Inclusion() #Predicat_Inclusion : {}{
 Expression() < Subset >  Expression()
}

void  Predicat_Inclusion_Stricte() #Predicat_Insclusion_Stricte : {}{
 Expression() < StrictSubset >  Expression()
}

void  Predicat_Non_Inclusion() #Predicat_Non_Inclusion : {}{
 Expression() < NotSubset >  Expression()
}

void  Predicat_Non_Inclusion_Stricte() #Predicat_Non_Inclusion_Stricte : {}{
 Expression() < NotStrictSubset >  Expression()
}

void  Predicat_Inferieur_Ou_Egal() #Predicat_Inferieur_Ou_Egal : {}{
 Expression() < LessThanOrEqual >  Expression()
}

void  Predicat_Strictement_Inferieur() #Predicat_Strictement_Inferieur : {}{
 Expression() < LessThan >  Expression()
}

void  Predicat_Strictement_Superieur() #Predicat_Strictement_Superieur : {}{
 Expression() < GreatherThan >  Expression()
}

void  Predicat_Superieur_Ou_Egal() #Predicat_Superieur_Ou_Egal : {}{
 Expression() < GreatherThanOrEqual >  Expression()
}

void Expression() #Expression : { } {
	 Expression_primaire()
|    Expression_booleenne()
|    Expression_arithmetique()
|    Expression_de_couples()
|    Expression_d_ensembles()
|    Construction_d_ensembles()
|    Expression_de_records()
|    Expression_de_relations()
|    Expression_de_fonctions()
|    Construction_de_fonctions()
|    Expression_de_suites()
|    Construction_de_suites()
//|    Expression_d_arbres() 
}

void Expression_primaire () #Expression_primaire : { } {
	Donnee()
| 	Expr_parenthesee()
| 	< String > 
}

void Expression_booleenne () #Expression_booleenne : { } {
	Boolean_lit() 
| 	Conversion_bool() 
}


void Expression_arithmetique() #ExprArith : {} {
	Entier_lit() ExpArithBis() 
| 	Ident_ren() 
[
	(<OpenParen > Terme() (<Comma> Terme())* <CloseParen>)
	| (< Quote > <IDENTIFIER> (< Quote > <IDENTIFIER>)*)
]  ExpArithBis() 
|	< Minus > Expression_arithmetique() ExpArithBis() 
|  	< Succ > <OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis() 
|  	< Pred > <OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis() 
|	< OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis()
| 	< Max > < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Min > < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Card > < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Sigma > Liste_ident() < Point > < OpenParen > Predicat() < SuchAs > Expression() < CloseParen > ExpArithBis()
| 	< Pi > Liste_ident() < Point > < OpenParen > Predicat() < SuchAs > Expression() < CloseParen > ExpArithBis()
}

void ExpArithBis() : {} {
	< Plus > Expression_arithmetique()  ExpArithBis() 
| 	< Minus > Expression_arithmetique()  ExpArithBis() 
| 	< Product > Expression_arithmetique()  ExpArithBis() 
| 	< Division > Expression_arithmetique() ExpArithBis() 
| 	< Modulo > Expression_arithmetique()  ExpArithBis() 
| 	< Power > Expression_arithmetique()  ExpArithBis()
|   {}
}

void Expression_de_couples() #Expression_de_couples : {} {
	Couple()
}

void Expression_d_ensembles() #Expression_d_ensembles : {} {
	Ensemble_vide()
|   Ensemble_entier()
|   Ensemble_booleen()
|   Ensemble_chaines()
}

void Construction_d_ensembles() #Construction_d_ensembles : {} {
	Expression() < Product > Expression() 
|   Ens_comprehension()
|   Sous_ensembles()
|   Sous_ensembles_finis()
|   Ens_extension()
|   Intervalle()
|   Difference()
|  	Union()
|   Intersection()
|   Union_generalisee()
|   Intersection_generalisee()
|   Union_quantifiee()
|   Intersection_quantifee()
}

void Expression_de_records() #Expression_de_records : {} {
	Ensemble_records()
|	Record_en_extension()
|	Champ_de_record()
}

void Expression_de_relations() #Expression_de_relations : {} {
	Ensemble_relations()
|	Identite()
|	Inverse()
|	Premiere_projection()
|	Deuxieme_projection()
|	Composition()
|	Produit_direct()
|	Produit_parallele()
|	Iteration()
|	Fermeture_reflexive()
|	Fermeture()
|	Domaine()
|	Codomaine()
|	Image()
|	Restriction_domaine()
|	Soustraction_domaine()
|	Restriction_codomaine()
|	Soustraction_codomaine()
|	Surcharge()
}

void Expression_de_fonctions() #Expression_de_fonctions : {} {
	Fonction_partielle()
|	Fonction_totale()
|	Injection_partielle()
|	Injection_totale()
|	Surjection_partielle()
|	Surjection_totale()
|	Bijection_totale()
}

void Construction_de_fonctions() #Construction_de_fonctions : {} {
	Lambda_expression()
|	evaluation_fonction()
|	Transformee_fonction()
|	Transformee_relation()
}

void Expression_de_suites() #Expression_de_suites : {} {
	Suites()
|	Suites_non_vide()
|	Suites_injectives()
|	Suites_inj_non_vide()
|	Permutations()
|	Suite_vide()
|	Suite_extension()
}

void Construction_de_suites() #Construction_de_suites : {} {
	Taille_suite()
|	Premier_element_suite()
|	Dernier_element_suite()
|	Tete_suite()
|	Queue_suite()
|	Inverse_suite()
|	Concatenation()
|	Insertion_tete()
|	Insertion_queue()
|	Restriction_tete()
|	Restriction_queue()
|	Concat_generalisee()
}

void Expr_parenthesee() #Expr_parenthesee : {} {
	< OpenParen > Expression() < CloseParen >
}

void Conversion_bool() #Conversion_bool : {} {
	< Bool > < OpenParen > Predicat() < CloseParen >
}

// TODO: Rajouter les autres opÃ©rations ?
void Difference() #Difference : { } { 
	Expression() < Minus > Expression()
}

void Couple() #Couple : {} {
	Expression() < Maplet > Expression()
| 	Expression() < Comma > Expression()
}

void Ensemble_vide() #Ensemble_vide : {} {
	< EmptySet > 
}

void Ensemble_entier() #Ensemble_entier : {} {
	< Nat >
| 	< Nat1 >
| 	< Natural >
| 	< Natural1 >
| 	< Int >
| 	< Integer >  
}

void Ensemble_chaines() #Ensemble_chaines : {} {
	< String >
}

void Ensemble_booleen() #Ensemble_booleen : {} {
	< Bool >
}

void Ens_comprehension() #Ens_comprehension : {} {
	<OpenBraces> < IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > Predicat() <CloseBraces>
}

void Sous_ensembles() #Sous_ensembles : {} {
	< POW > < OpenParen >  Expression() < CloseParen >
|	< POW1 > < OpenParen >  Expression() < CloseParen >
}

void Sous_ensembles_finis() #Sous_ensembles_finis : {} {
    < FIN > < OpenParen >  Expression() < CloseParen >
|   < FIN1 > < OpenParen >  Expression() < CloseParen >
}

void Ens_extension() #Ens_extension : {} {
	<OpenBraces> Expression() (< Comma > Expression())*  <CloseBraces>
}

void Intervalle() #Intervalle : {} {
	Expression() < In > Expression()
}

void Union() #Union : {} {
	Expression() < Union > Expression()
}

void Intersection() #Intersection : {} {
	Expression() < Intersection > Expression()
}

void Union_generalisee() #Union_generalisee : {} {
	< UnionGen > < OpenParen >  Expression() < CloseParen >
}
void Intersection_generalisee() #Intersection_generalisee : {} {
	< InterGen > < OpenParen >  Expression() < CloseParen >
}
void Union_quantifiee() #Union_quantifiee : {} {
	< UnionQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen >
}
void Intersection_quantifee() #Intersection_quantifiee : {} {
	< InterQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen >
}
void Ensemble_records() #Ensemble_records : {} {
	< Struct > < OpenParen >  < IDENTIFIER > < In > Expression() (< Comma > < IDENTIFIER > < In > Expression() )* < CloseParen >
}
void Record_en_extension() #Record_en_extension : {} {
	< Rec > < OpenParen >  [< IDENTIFIER > < In >] Expression() (< Comma > [ < IDENTIFIER > < In > ] Expression())* < CloseParen >
}
void Champ_de_record() #Champ_de_record : {} {
	Expression() < Quote > < IDENTIFIER >
}
void Ensemble_relations() #Ensemble_relations : {} {
	Expression() < Relation > Expression()
}

void Identite() #Identite : {} {
	< Id > < OpenParen >  Expression() < CloseParen >
}

void Inverse() #Inverse : {} {
	Expression() < Tilde > 
}

void Premiere_projection() #Premiere_projection : {} {
	< Prj1 > < OpenParen > Expression() < Comma > Expression() < CloseParen >
}

void Deuxieme_projection() #Deuxieme_projection : {} {
	< Prj2 > < OpenParen > Expression() < Comma > Expression() < CloseParen >
}
void Composition() #Composition : {} {
	Expression() < SemiColon > Expression()
}
void Produit_direct() #Produit_direct : {} {
	Expression() < DirectProduct > Expression()
}
void Produit_parallele() #Produit_parallele : {} {
	Expression() < Parallel > Expression()
}
void Iteration() #Iteration : {} {
	Expression() Expression()
}
void Fermeture_reflexive() #Fermeture_reflexive : {} {
	Expression() < Closure >
}
void Fermeture() #Fermeture : {} {
	Expression() < Closure1 >
}
void Domaine() #Domaine : {} {
	< Dom > < OpenParen >  Expression() < CloseParen >
}
void Codomaine() #Codomaine : {} {
	< Ran > < OpenParen >  Expression() < CloseParen >
}

void Image() #Image : {} {
	Expression() < OpenCurly > Expression() < CloseCurly >
}
void Restriction_domaine() #Restriction_domaine : {} {
	Expression() < DomainRestriction > Expression()
}
void Soustraction_domaine() #Soustraction_domaine : {} {
	Expression() < DomainSubstraction > Expression()
}
void Restriction_codomaine() #Restriction_codomaine : {} {
	Expression() < RangeRestriction > Expression()
}
void Soustraction_codomaine() #Soustraction_codomaine : {} {
	Expression() < RangeSubstraction > Expression()
}
void Surcharge() #Surcharge : {} {
	Expression() < Override > Expression()
}
void Fonction_partielle() #Fonction_partielle : {} {
	Expression() < PartialFunction > Expression()
}
void Fonction_totale() #Fonction_totale : {} {
	Expression() < TotalFunction > Expression()
}
void Injection_partielle() #Injection_partielle : {} {
	Expression() < PartialInjection > Expression()
}
void Injection_totale() #Injection_totale : {} {
	Expression() < TotalInjection > Expression()
}
void Surjection_partielle() #Surjection_partielle : {} {
	Expression() < PartialSurjection > Expression()
}
void Surjection_totale() #Surjection_totale : {} {
	Expression() < TotalSurjection > Expression()
}
void Bijection_totale() #Bijection_totale : {} {
	Expression() < TotalBijection > Expression()
}
void Lambda_expression() #Lambda_expression() : {} {
	< Lambda > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen >
}
void evaluation_fonction() #evaluation_fonction : {} {
	Expression() < OpenParen >  Expression() < CloseParen >
}
void Transformee_fonction() #Transformee_fonction : {} {
	< Fnc > < OpenParen >  Expression() < CloseParen >
}
void Transformee_relation() #Transformee_relation : {} {
	< Rel > < OpenParen >  Expression() < CloseParen >
}
void Suites() #Suites : {} {
	< Seq > < OpenParen >  Expression() < CloseParen >
}
void Suites_non_vide() #Suites_non_vide : {} {
	< Seq1 > < OpenParen >  Expression() < CloseParen >
}
void Suites_injectives() #Suites_injectives : {} {
	< Iseq > < OpenParen >  Expression() < CloseParen >
}
void Suites_inj_non_vide() #Suites_inj_non_vide : {} {
	< Iseq1 > < OpenParen >  Expression() < CloseParen >
}
void Permutations() #Permutations : {} {
	< Perm > < OpenParen >  Expression() < CloseParen >
}
void Suite_vide() #Suite_vide : {} {
	< EmptySequence >
}
void Suite_extension() #Suite_extension : {} {
	< OpenCurly > Expression() (< Comma > Expression())*  < CloseCurly >
}
void Taille_suite() #Taille_suite : {} {
 	<Size> < OpenParen >  Expression() < CloseParen >
}
void Premier_element_suite() #Premier_element_suite : {} {
	<First> < OpenParen >  Expression() < CloseParen >
}
void Dernier_element_suite() #Dernier_element_suite : {} {
	<Last>  < OpenParen >  Expression() < CloseParen >
}
void Tete_suite() #Tete_suite : {} {
	<Front> < OpenParen >  Expression() < CloseParen >
}
void Queue_suite() #Queue_suite : {} {
	<Tail> < OpenParen >  Expression() < CloseParen >
}
void Inverse_suite() #Inverse_suite : {} {
	< Rev > < OpenParen >  Expression() < CloseParen >
}
void Concatenation() #Concatenation : {} {
	Expression()  < Conc >  Expression()
}
void Insertion_tete() #Insertion_tete : {} {
	Expression() <  PrependSequence >  Expression()
}

void Insertion_queue() #Insertion_queue : {} {
	Expression() < AppendSequence >  Expression()
}
void Restriction_tete() #Restriction_tete : {} {
	Expression() < PrefixSequence > Expression()
}
void Restriction_queue() #Restriction_queue : {} {
	Expression() < SuffixSequence > Expression()
}
void Concat_generalisee() #Concat_generalisee : {} {
	< Conc > < OpenParen >  Expression() < CloseParen >
}
void Arbres() #Arbres : {} {
	< Tree > < OpenParen >  Expression() < CloseParen >
}
void Arbres_binaires() #Arbres_binaires : {} {
	< Btree >  < OpenParen >  Expression() < CloseParen >
}
void Construction_arbre() #Construction_arbre : {} {
	< Const > < OpenParen >  Expression() < Comma > Expression() < CloseParen >
}
void Racine_arbre() #Racine_arbre : {} {
	< Top > < OpenParen >  Expression() < CloseParen >
}
void Fils_arbre() #Fils_arbre : {} {
	< Sons > < OpenParen >  Expression() < CloseParen >
}
void Aplatissement_prefixe() #Aplatissement_prefixe : {} {
	< Prefix > < OpenParen >  Expression() < CloseParen >
}
void Aplatissement_postfixe() #Aplatissement_postfixe : {} {
	< Postfix > < OpenParen >  Expression() < CloseParen >
}
void Taille_arbre() #Taille_arbre : {} {
	< Sizet > < OpenParen >  Expression() < CloseParen >
}
void Symetrie_arbre() #Symetrie_arbre : {} {
	< Mirror > < OpenParen >  Expression() < CloseParen >
}
void Rang_noeud() #Rang_noeud : {} {
	< Rank > < OpenParen >  Expression() < Comma > Expression() < CloseParen >
}
void Pere_noeud() #Pere_noeud : {} {
	< Father > < OpenParen >  Expression() < Comma > Expression() < CloseParen >
}
void Fils_noeud() #Fils_noeud : {} {
	< Son > < OpenParen >  Expression() < Comma > Expression() < Comma > Expression() < CloseParen >
}

void Sous_arbre_noeud() #Sous_arbre_noeud : {} {
	< Subtree > < OpenParen > Expression() < Comma > Expression() < CloseParen >
}
void Arite_noeud() #Arite_noeud : {} {
	< Arity > < OpenParen >  Expression() < Comma > Expression() < CloseParen >
}
void Arbre_binaire_en_extension() #Arbre_binaire_en_extension : {} {
	< Bin > < OpenParen >  Expression() [ < Comma > Expression() < Comma > Expression() ] < CloseParen >
}
void Sous_arbre_gauche() #Sous_arbre_gauche : {} {
	< Left > < OpenParen >  Expression() < CloseParen >
}
void Sous_arbre_droit() #Sous_arbre_droit : {} {
	< Right > < OpenParen >  Expression() < CloseParen >
}
void Aplatissement_infixe() #Aplatissement_infixe : {} {
	< Infix > < OpenParen >  Expression() < CloseParen >
}

void Substitution() #Substitution : {} {
	Substitution_bloc()
|	Substitution_identite()
|	Substitution_devient_egal()
|	Substitution_precondition()
|	Substitution_assertion()
|	Substitution_choix_borne()
|	Substitution_conditionnelle()
|	Substitution_selection()
|	Substitution_cas()
|	Substitution_choix_non_borne()
|	Substitution_definition_locale()
|	Substitution_devient_elt_de()
|	Substitution_devient_tel_que()
|	Substitution_variable_locale()
|	Substitution_sequence()
|	Substitution_appel_operation()
|	Substitution_simultanee()
|	Substitution_tant_que()
}

void Substitution_corps_operation() #Substitution_corps_operation : {} {
	Substitution_bloc()
|	Substitution_identite()
|	Substitution_devient_egal()
|	Substitution_precondition()
|	Substitution_assertion()
|	Substitution_choix_borne()
|	Substitution_conditionnelle()
|	Substitution_selection()
|	Substitution_cas()
|	Substitution_choix_non_borne()
|	Substitution_definition_locale()
|	Substitution_devient_elt_de()
|	Substitution_devient_tel_que()
|	Substitution_variable_locale()
|	Substitution_appel_operation()
}

void Substitution_bloc() #Substitution_bloc : {} {
	< Begin > Substitution() < End >
}

void Substitution_identite() #Substitution_identite : {} {
	< Skip >
}

void Substitution_devient_egal() #Substitution_devient_egal : {} {
	Ident_ren() (< Comma > Ident_ren())* < DevientEgal > Expression() (< Comma > Expression())*
|	Ident_ren() < OpenParen > Expression() (< Comma > Expression())* < CloseParen > < DevientEgal > Expression()
|	Ident_ren() < Quote > < IDENTIFIER > (< Quote > < IDENTIFIER >)* < DevientEgal > Expression()
}

void Substitution_precondition() #Substitution_precondition : {} {
	< Pre > Predicat() < Then > Substitution() < End >
}

void Substitution_assertion() #Substitution_assertion : {} {
	< Assert > Predicat() < Then > Substitution() < End >
}

void Substitution_choix_borne() #Substitution_choix_borne : {} {
	< Choice > Substitution() ( < OrC > Substitution() )* < End >
}

void Substitution_conditionnelle() #Substitution_conditionnelle : {} {
	< If > Predicat() < Then > Substitution()
	( < Elsif > Predicat() < Then > Substitution() )*
	[ < Else > Substitution() ]
	< End >
}

void Substitution_selection() #Substitution_selection : {} {
	< Select > Predicat() < Then > Substitution()
	( < When > Predicat() < Then > Substitution() )*
	[ < Else > Substitution()]
	< End >
}

void Substitution_cas() #Substitution_cas : {} {
	< Case > Expression() < Of >
	< Either > Terme_simple() (< Comma > Terme_simple())* < Then > Substitution()
	( < OrC > Terme_simple() (< Comma > Terme_simple())* < Then > Substitution() )*
	[ < Else > Substitution() ]
	< End >
	< End >
}

void Substitution_choix_non_borne() #Substitution_choix_non_borne : {} {
	< Any > < IDENTIFIER > (< Comma > < IDENTIFIER >)* < Where > Predicat() < Then > Substitution() < End >
}

void Substitution_definition_locale() #Substitution_definition_locale : {} {
	< Let > < IDENTIFIER > (< Comma > < IDENTIFIER >)* < Be >
	< IDENTIFIER > < Equal > Expression() ( < ConcatSequence > < IDENTIFIER > < Equal > Expression() )*
	< InLetVar > Substitution() < End >
}

void Substitution_devient_elt_de() #Substitution_devient_elt_de : {} {
	Ident_ren()(< Comma > < IDENTIFIER >)* < SetIn > Expression()
}

void Substitution_devient_tel_que() #Substitution_devient_tel_que : {} {
	Ident_ren()(< Comma > Ident_ren())* < In > < OpenParen > Predicat() < CloseParen >
}

void Substitution_variable_locale() #Substitution_variable_locale : {} {
	< Var > < IDENTIFIER >(< Comma > Ident_ren())* < InLetVar > Substitution() < End >
}

void Substitution_sequence() #Substitution_sequence : {} {
	Substitution() < SemiColon > Substitution()
}

void Substitution_appel_operation() #Substitution_appel_operation : {} {
	[ Ident_ren()(< Comma > Ident_ren())* < OperationReturn > ] Ident_ren() [ < OpenParen > Expression()(< Comma > Expression())* < CloseParen > ]
}

void Substitution_simultanee() #Substitution_simultanee : {} {
	Substitution() < Parallel > Substitution()
}

void Liste_ident() #Liste_ident : {} {  
	< IDENTIFIER >
| 	< OpenParen > < IDENTIFIER >  (< Comma > < IDENTIFIER >)* < CloseParen >
}

void Ensemble_simple() #Ensemble_simple : { } { 
	< Bool > 
| 	< IDENTIFIER > 
}