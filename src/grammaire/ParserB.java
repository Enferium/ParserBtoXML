/* ParserB.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. ParserB.java */
package grammaire ;

import java.io.*;
import java.util.*;

public class ParserB/*@bgen(jjtree)*/implements ParserBTreeConstants, ParserBConstants {/*@bgen(jjtree)*/
  protected JJTParserBState jjtree = new JJTParserBState();

  final public ASTStart Start() throws ParseException {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Composant();
jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
{if ("" != null) return jjtn000;}
    } catch (Throwable jjte000) {
if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Donnee() throws ParseException {
    Ident_ren();
  }

  final public void Ident_ren() throws ParseException {/*@bgen(jjtree) Ident_ren */
  ASTIdent_ren jjtn000 = new ASTIdent_ren(JJTIDENT_REN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Point:{
          ;
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        jj_consume_token(Point);
        jj_consume_token(IDENTIFIER);
      }
    } finally {
if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
  }

  final public void Composant() throws ParseException {
    Machine_abstraite();
  }

  final public void Machine_abstraite() throws ParseException {/*@bgen(jjtree) Machine */
  ASTMachine jjtn000 = new ASTMachine(JJTMACHINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Machine);
      EnTete();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Sets:
        case Invariant:
        case Variables:
        case Operations:
        case Constraints:
        case Constants:
        case Properties:
        case ConcreteVariables:
        case AbstractVariables:
        case ConcreteConstants:
        case AbstractConstants:
        case Initialisation:{
          ;
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        Clause_machine_abstraite();
      }
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_machine_abstraite() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case Constraints:{
      Clause_constraints();
      break;
      }
    case Sets:{
      Clause_sets();
      break;
      }
    case Constants:
    case ConcreteConstants:{
      Clause_concrete_constants();
      break;
      }
    case AbstractConstants:{
      Clause_abstract_constants();
      break;
      }
    case Properties:{
      Clause_properties();
      break;
      }
    case ConcreteVariables:{
      Clause_concrete_variables();
      break;
      }
    case Variables:
    case AbstractVariables:{
      Clause_abstract_variables();
      break;
      }
    case Invariant:{
      Clause_invariant();
      break;
      }
    case Initialisation:{
      Clause_initialisation();
      break;
      }
    case Operations:{
      Clause_operations();
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void EnTete() throws ParseException {/*@bgen(jjtree) EnTete */
  ASTEnTete jjtn000 = new ASTEnTete(JJTENTETE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        jj_consume_token(OpenParen);
        jj_consume_token(IDENTIFIER);
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[3] = jj_gen;
            break label_3;
          }
          jj_consume_token(Comma);
          jj_consume_token(IDENTIFIER);
        }
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        ;
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_constraints() throws ParseException {/*@bgen(jjtree) Constraints */
  ASTConstraints jjtn000 = new ASTConstraints(JJTCONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Constraints);
      Predicat();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instanciation() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OpenParen:
    case Minus:
    case Card:
    case Max:
    case Min:
    case Succ:
    case Pred:
    case Sigma:
    case Pi:
    case Rec:
    case True:
    case False:
    case Boolean:
    case MaxInt:
    case MinInt:
    case IDENTIFIER:
    case Number:{
      Terme();
      break;
      }
    case Nat:
    case Nat1:
    case Natural:
    case Natural1:
    case Int:
    case Integer:{
      Ensemble_entier();
      break;
      }{
      jj_consume_token(Boolean);
      break;
      }
    case EmptySet:
    case Lambda:
    case OpenBraces:
    case POW:
    case FIN:
    case POW1:
    case FIN1:
    case InterGen:
    case UnionGen:
    case UnionQuant:
    case InterQuant:
    case Id:
    case Fnc:
    case Rel:
    case Bool:
    case String:{
      Expression();
      jj_consume_token(In);
      Expression();
      break;
      }
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Clause_sets() throws ParseException {/*@bgen(jjtree) Sets */
  ASTSets jjtn000 = new ASTSets(JJTSETS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Sets);
      Ensemble();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SemiColon:{
          ;
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          break label_4;
        }
        jj_consume_token(SemiColon);
        Ensemble();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Ensemble() throws ParseException {/*@bgen(jjtree) Ensemble */
  ASTEnsemble jjtn000 = new ASTEnsemble(JJTENSEMBLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Equal:{
        jj_consume_token(Equal);
        jj_consume_token(OpenBraces);
        jj_consume_token(IDENTIFIER);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[7] = jj_gen;
            break label_5;
          }
          jj_consume_token(Comma);
          jj_consume_token(IDENTIFIER);
        }
        jj_consume_token(CloseBraces);
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        ;
      }
    } finally {
if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Clause_concrete_constants() throws ParseException {/*@bgen(jjtree) ConcreteConstants */
  ASTConcreteConstants jjtn000 = new ASTConcreteConstants(JJTCONCRETECONSTANTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ConcreteConstants:{
        jj_consume_token(ConcreteConstants);
        break;
        }
      case Constants:{
        jj_consume_token(Constants);
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(IDENTIFIER);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          break label_6;
        }
        jj_consume_token(Comma);
        jj_consume_token(IDENTIFIER);
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_abstract_constants() throws ParseException {/*@bgen(jjtree) AbstractConstants */
  ASTAbstractConstants jjtn000 = new ASTAbstractConstants(JJTABSTRACTCONSTANTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(AbstractConstants);
      jj_consume_token(IDENTIFIER);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          break label_7;
        }
        jj_consume_token(Comma);
        jj_consume_token(IDENTIFIER);
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_properties() throws ParseException {/*@bgen(jjtree) Properties */
  ASTProperties jjtn000 = new ASTProperties(JJTPROPERTIES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Properties);
      Predicat();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_values() throws ParseException {/*@bgen(jjtree) Values */
  ASTValues jjtn000 = new ASTValues(JJTVALUES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Values);
      Valuation();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SemiColon:{
          ;
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          break label_8;
        }
        jj_consume_token(SemiColon);
        Valuation();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Valuation() throws ParseException {/*@bgen(jjtree) Value */
  ASTValue jjtn000 = new ASTValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
      jj_consume_token(Equal);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:
      case Minus:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case Rec:
      case True:
      case False:
      case Boolean:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case Number:{
        Terme();
        break;
        }
      case OpenBraces:
      case Bool:{
        Expr_tableau();
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_concrete_variables() throws ParseException {/*@bgen(jjtree) ConcreteVariables */
  ASTConcreteVariables jjtn000 = new ASTConcreteVariables(JJTCONCRETEVARIABLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ConcreteVariables);
      Ident_ren();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          break label_9;
        }
        jj_consume_token(Comma);
        Ident_ren();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_abstract_variables() throws ParseException {/*@bgen(jjtree) AbstractVariables */
  ASTAbstractVariables jjtn000 = new ASTAbstractVariables(JJTABSTRACTVARIABLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AbstractVariables:{
        jj_consume_token(AbstractVariables);
        break;
        }
      case Variables:{
        jj_consume_token(Variables);
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Ident_ren();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          break label_10;
        }
        jj_consume_token(Comma);
        Ident_ren();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_invariant() throws ParseException {/*@bgen(jjtree) Invariant */
  ASTInvariant jjtn000 = new ASTInvariant(JJTINVARIANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Invariant);
      Predicat();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_initialisation() throws ParseException {/*@bgen(jjtree) Initialisation */
  ASTInitialisation jjtn000 = new ASTInitialisation(JJTINITIALISATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Initialisation);
      Substitution();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Clause_operations() throws ParseException {/*@bgen(jjtree) Operations */
  ASTOperations jjtn000 = new ASTOperations(JJTOPERATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Operations);
      Operation();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SemiColon:{
          ;
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          break label_11;
        }
        jj_consume_token(SemiColon);
        Operation();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Operation() throws ParseException {/*@bgen(jjtree) Operation */
  ASTOperation jjtn000 = new ASTOperation(JJTOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Entete_operation();
      jj_consume_token(Equal);
      Substitution_corps_operation();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Entete_operation() throws ParseException {/*@bgen(jjtree) EnteteOperation */
  ASTEnteteOperation jjtn000 = new ASTEnteteOperation(JJTENTETEOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case SemiColon:{
            ;
            break;
            }
          default:
            jj_la1[18] = jj_gen;
            break label_12;
          }
          jj_consume_token(SemiColon);
          jj_consume_token(IDENTIFIER);
        }
        jj_consume_token(OperationReturn);
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      Ident_ren();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        jj_consume_token(OpenParen);
        jj_consume_token(IDENTIFIER);
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[20] = jj_gen;
            break label_13;
          }
          jj_consume_token(Comma);
          jj_consume_token(IDENTIFIER);
        }
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Terme() throws ParseException {/*@bgen(jjtree) Terme */
  ASTTerme jjtn000 = new ASTTerme(JJTTERME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case True:
      case False:
      case Boolean:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case Number:{
        Terme_simple();
        break;
        }
      case OpenParen:
      case Minus:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:{
        Expression_arithmetique();
        break;
        }
      case Rec:{
        Terme_record();
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case OpenParen:{
            ;
            break;
            }
          default:
            jj_la1[22] = jj_gen;
            break label_14;
          }
          jj_consume_token(OpenParen);
          jj_consume_token(Quote);
          jj_consume_token(IDENTIFIER);
          jj_consume_token(CloseParen);
        }
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Terme_simple() throws ParseException {/*@bgen(jjtree) TermeSimple */
  ASTTermeSimple jjtn000 = new ASTTermeSimple(JJTTERMESIMPLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        Ident_ren();
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case OpenParen:{
            ;
            break;
            }
          default:
            jj_la1[24] = jj_gen;
            break label_15;
          }
          jj_consume_token(OpenParen);
          jj_consume_token(Quote);
          jj_consume_token(IDENTIFIER);
          jj_consume_token(CloseParen);
        }
        break;
        }
      case MaxInt:
      case MinInt:
      case Number:{
        Entier_lit();
        break;
        }
      case True:
      case False:{
        Boolean_lit();
        break;
        }
      case Boolean:{
        jj_consume_token(Boolean);
        jj_consume_token(OpenParen);
        Condition();
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Entier_lit() throws ParseException {/*@bgen(jjtree) Entier_Lit */
  ASTEntier_Lit jjtn000 = new ASTEntier_Lit(JJTENTIER_LIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Number:{
        jj_consume_token(Number);
        break;
        }
      case MaxInt:{
        jj_consume_token(MaxInt);
        break;
        }
      case MinInt:{
        jj_consume_token(MinInt);
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Boolean_lit() throws ParseException {/*@bgen(jjtree) Boolean_Lit */
  ASTBoolean_Lit jjtn000 = new ASTBoolean_Lit(JJTBOOLEAN_LIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case False:{
        jj_consume_token(False);
        break;
        }
      case True:{
        jj_consume_token(True);
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Terme_record() throws ParseException {/*@bgen(jjtree) Terme_record */
  ASTTerme_record jjtn000 = new ASTTerme_record(JJTTERME_RECORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Rec);
      jj_consume_token(OpenParen);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        jj_consume_token(In);
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:
      case Minus:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case Rec:
      case True:
      case False:
      case Boolean:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case Number:{
        Terme();
        break;
        }
      case OpenBraces:
      case Bool:{
        Expr_tableau();
        break;
        }
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[30] = jj_gen;
          break label_16;
        }
        jj_consume_token(Comma);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          jj_consume_token(IDENTIFIER);
          jj_consume_token(In);
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:
        case Minus:
        case Card:
        case Max:
        case Min:
        case Succ:
        case Pred:
        case Sigma:
        case Pi:
        case Rec:
        case True:
        case False:
        case Boolean:
        case MaxInt:
        case MinInt:
        case IDENTIFIER:
        case Number:{
          Terme();
          break;
          }
        case OpenBraces:
        case Bool:{
          Expr_tableau();
          break;
          }
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Expr_tableau() throws ParseException {/*@bgen(jjtree) Expr_tableau */
  ASTExpr_tableau jjtn000 = new ASTExpr_tableau(JJTEXPR_TABLEAU);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        break;
        }
      case OpenBraces:{
        jj_consume_token(OpenBraces);
        Terme_simple();
        label_17:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Maplet:{
            ;
            break;
            }
          default:
            jj_la1[33] = jj_gen;
            break label_17;
          }
          jj_consume_token(Maplet);
          Terme_simple();
        }
        jj_consume_token(Maplet);
        Terme();
        label_18:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[34] = jj_gen;
            break label_18;
          }
          jj_consume_token(Comma);
          Terme_simple();
          label_19:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case Maplet:{
              ;
              break;
              }
            default:
              jj_la1[35] = jj_gen;
              break label_19;
            }
            jj_consume_token(Maplet);
            Terme_simple();
          }
          jj_consume_token(Maplet);
          Terme();
        }
        jj_consume_token(CloseBraces);
        break;
        }
      case Bool:{
        Ensemble_simple();
        jj_consume_token(Product);
        Ensemble_simple();
        jj_consume_token(Product);
        jj_consume_token(OpenBraces);
        Terme();
        jj_consume_token(CloseBraces);
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Condition() throws ParseException {/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case True:
      case False:
      case Boolean:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case Number:{
        Terme_simple();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Equal:{
          jj_consume_token(Equal);
          break;
          }
        case NotEqual:{
          jj_consume_token(NotEqual);
          break;
          }
        case LessThan:{
          jj_consume_token(LessThan);
          break;
          }
        case GreatherThan:{
          jj_consume_token(GreatherThan);
          break;
          }
        case LessThanOrEqual:{
          jj_consume_token(LessThanOrEqual);
          break;
          }
        case GreatherThanOrEqual:{
          jj_consume_token(GreatherThanOrEqual);
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Terme_simple();
        CondBis();
        break;
        }
      case Not:{
        jj_consume_token(Not);
        Condition();
        CondBis();
        break;
        }
      case OpenParen:{
        jj_consume_token(OpenParen);
        Condition();
        jj_consume_token(CloseParen);
        CondBis();
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void CondBis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case And:{
      jj_consume_token(And);
      Condition();
      CondBis();
      break;
      }
    case Or:{
      jj_consume_token(Or);
      Condition();
      CondBis();
      break;
      }
    default:
      jj_la1[39] = jj_gen;

    }
  }

  final public void Instruction() throws ParseException {/*@bgen(jjtree) Instruction */
  ASTInstruction jjtn000 = new ASTInstruction(JJTINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Begin:{
        Instruction_bloc();
        break;
        }
      case Var:{
        Instruction_variable_locale();
        break;
        }
      case Skip:{
        Substitution_identite();
        break;
        }
      case IDENTIFIER:{
        Instruction_devient_egal();
        break;
        }{
        Instruction_appel_operation();
        break;
        }
      case If:{
        Instruction_conditionnelle();
        break;
        }
      case Case:{
        Instruction_cas();
        break;
        }
      case Assert:{
        Instruction_assertion();
        break;
        }
      case While:{
        Instruction_sequence();
        break;
        }{
        Substitution_tant_que();
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_corps_operation() throws ParseException {/*@bgen(jjtree) Instruction_corps_operation */
  ASTInstruction_corps_operation jjtn000 = new ASTInstruction_corps_operation(JJTINSTRUCTION_CORPS_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Begin:{
        Instruction_bloc();
        break;
        }
      case Var:{
        Instruction_variable_locale();
        break;
        }
      case Skip:{
        Substitution_identite();
        break;
        }
      case IDENTIFIER:{
        Instruction_devient_egal();
        break;
        }{
        Instruction_appel_operation();
        break;
        }
      case If:{
        Instruction_conditionnelle();
        break;
        }
      case Case:{
        Instruction_cas();
        break;
        }
      case Assert:{
        Instruction_assertion();
        break;
        }
      case While:{
        Substitution_tant_que();
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_bloc() throws ParseException {/*@bgen(jjtree) Instruction_bloc */
  ASTInstruction_bloc jjtn000 = new ASTInstruction_bloc(JJTINSTRUCTION_BLOC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Begin);
      Instruction();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_variable_locale() throws ParseException {/*@bgen(jjtree) Instruciton_variable_locale */
  ASTInstruciton_variable_locale jjtn000 = new ASTInstruciton_variable_locale(JJTINSTRUCITON_VARIABLE_LOCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Var);
      jj_consume_token(IDENTIFIER);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[42] = jj_gen;
          break label_20;
        }
        jj_consume_token(Comma);
        jj_consume_token(IDENTIFIER);
      }
      jj_consume_token(In);
      Instruction();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_devient_egal() throws ParseException {/*@bgen(jjtree) Instruction_devient_egal */
  ASTInstruction_devient_egal jjtn000 = new ASTInstruction_devient_egal(JJTINSTRUCTION_DEVIENT_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Ident_ren();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DevientEgal:
      case OpenParen:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:{
          jj_consume_token(OpenParen);
          Terme();
          label_21:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case Comma:{
              ;
              break;
              }
            default:
              jj_la1[43] = jj_gen;
              break label_21;
            }
            jj_consume_token(Comma);
            Terme();
          }
          jj_consume_token(CloseParen);
          break;
          }
        default:
          jj_la1[44] = jj_gen;
          ;
        }
        jj_consume_token(DevientEgal);
        Terme();
        break;
        }{
        jj_consume_token(DevientEgal);
        Expr_tableau();
        break;
        }
      case Quote:{
        jj_consume_token(Quote);
        jj_consume_token(IDENTIFIER);
        label_22:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Quote:{
            ;
            break;
            }
          default:
            jj_la1[45] = jj_gen;
            break label_22;
          }
          jj_consume_token(Quote);
          jj_consume_token(IDENTIFIER);
        }
        jj_consume_token(DevientEgal);
        Terme();
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_appel_operation() throws ParseException {/*@bgen(jjtree) Instruction_appel_operation */
  ASTInstruction_appel_operation jjtn000 = new ASTInstruction_appel_operation(JJTINSTRUCTION_APPEL_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        Ident_ren();
        label_23:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[47] = jj_gen;
            break label_23;
          }
          jj_consume_token(Comma);
          Ident_ren();
        }
        jj_consume_token(OperationReturn);
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        ;
      }
      Ident_ren();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        jj_consume_token(OpenParen);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:
        case Minus:
        case Card:
        case Max:
        case Min:
        case Succ:
        case Pred:
        case Sigma:
        case Pi:
        case Rec:
        case True:
        case False:
        case Boolean:
        case MaxInt:
        case MinInt:
        case IDENTIFIER:
        case Number:{
          Terme();
          break;
          }
        case String:{
          jj_consume_token(String);
          break;
          }
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[50] = jj_gen;
            break label_24;
          }
          jj_consume_token(Comma);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case OpenParen:
          case Minus:
          case Card:
          case Max:
          case Min:
          case Succ:
          case Pred:
          case Sigma:
          case Pi:
          case Rec:
          case True:
          case False:
          case Boolean:
          case MaxInt:
          case MinInt:
          case IDENTIFIER:
          case Number:{
            Terme();
            break;
            }
          case String:{
            jj_consume_token(String);
            break;
            }
          default:
            jj_la1[51] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_sequence() throws ParseException {/*@bgen(jjtree) Instruction_sequence */
  ASTInstruction_sequence jjtn000 = new ASTInstruction_sequence(JJTINSTRUCTION_SEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Begin:{
        Instruction_bloc();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      case Var:{
        Instruction_variable_locale();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      case Skip:{
        Substitution_identite();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      case IDENTIFIER:{
        Instruction_devient_egal();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }{
        Instruction_appel_operation();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      case If:{
        Instruction_conditionnelle();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      case Case:{
        Instruction_cas();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      case Assert:{
        Instruction_assertion();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      case While:{
        Substitution_tant_que();
        jj_consume_token(SemiColon);
        Instruction();
        InstrSeqBis();
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void InstrSeqBis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SemiColon:{
      jj_consume_token(SemiColon);
      Instruction();
      InstrSeqBis();
      break;
      }
    default:
      jj_la1[54] = jj_gen;

    }
  }

  final public void Instruction_conditionnelle() throws ParseException {/*@bgen(jjtree) Instruction_conditionnelle */
  ASTInstruction_conditionnelle jjtn000 = new ASTInstruction_conditionnelle(JJTINSTRUCTION_CONDITIONNELLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(If);
      Condition();
      jj_consume_token(Then);
      Instruction();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Elsif:{
          ;
          break;
          }
        default:
          jj_la1[55] = jj_gen;
          break label_25;
        }
        jj_consume_token(Elsif);
        Condition();
        jj_consume_token(Then);
        Instruction();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Else:{
        jj_consume_token(Else);
        Instruction();
        break;
        }
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_cas() throws ParseException {/*@bgen(jjtree) Instruction_cas */
  ASTInstruction_cas jjtn000 = new ASTInstruction_cas(JJTINSTRUCTION_CAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Case);
      Terme_simple();
      jj_consume_token(Of);
      jj_consume_token(Either);
      Terme_simple();
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[57] = jj_gen;
          break label_26;
        }
        jj_consume_token(Comma);
        Terme_simple();
      }
      jj_consume_token(Then);
      Instruction();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Or:{
          ;
          break;
          }
        default:
          jj_la1[58] = jj_gen;
          break label_27;
        }
        jj_consume_token(Or);
        Terme_simple();
        label_28:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[59] = jj_gen;
            break label_28;
          }
          jj_consume_token(Comma);
          Terme_simple();
        }
        jj_consume_token(Then);
        Instruction();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Else:{
        jj_consume_token(Else);
        Instruction();
        break;
        }
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      jj_consume_token(End);
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_tant_que() throws ParseException {/*@bgen(jjtree) Substitution_tant_que */
  ASTSubstitution_tant_que jjtn000 = new ASTSubstitution_tant_que(JJTSUBSTITUTION_TANT_QUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(While);
      Condition();
      jj_consume_token(Do);
      Instruction();
      jj_consume_token(Invariant);
      Predicat();
      jj_consume_token(Variant);
      Expression();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Instruction_assertion() throws ParseException {/*@bgen(jjtree) Instruction_assertion */
  ASTInstruction_assertion jjtn000 = new ASTInstruction_assertion(JJTINSTRUCTION_ASSERTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Assert);
      Condition();
      jj_consume_token(Then);
      Instruction();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Predicat() throws ParseException {/*@bgen(jjtree) predicat */
  ASTpredicat jjtn000 = new ASTpredicat(JJTPREDICAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        Predicat_Parenthese();
        break;
        }
      case EmptySet:
      case Lambda:
      case Forall:
      case Exists:
      case OpenBraces:
      case Not:
      case Minus:
      case POW:
      case FIN:
      case POW1:
      case FIN1:
      case InterGen:
      case UnionGen:
      case UnionQuant:
      case InterQuant:
      case Id:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case Fnc:
      case Rel:
      case Bool:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:
      case True:
      case False:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case String:
      case Number:{
        Predicat_Conjonction();
        break;
        }{
        Predicat_Negation();
        break;
        }{
        Predicat_Disjonction();
        break;
        }{
        Predicat_Implication();
        break;
        }{
        Predicat_Equivalence();
        break;
        }{
        Predicat_Universel();
        break;
        }{
        Predicat_Existentiel();
        break;
        }{
        Predicat_Egalite();
        break;
        }{
        Predicat_Inegalite();
        break;
        }{
        Predicat_Appartenance();
        break;
        }{
        Predicat_Non_Appartenance();
        break;
        }{
        Predicat_Inclusion();
        break;
        }{
        Predicat_Inclusion_Stricte();
        break;
        }{
        Predicat_Non_Inclusion();
        break;
        }{
        Predicat_Non_Inclusion_Stricte();
        break;
        }{
        Predicat_Inferieur_Ou_Egal();
        break;
        }{
        Predicat_Strictement_Inferieur();
        break;
        }{
        Predicat_Superieur_Ou_Egal();
        break;
        }{
        Predicat_Strictement_Superieur();
        break;
        }
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Predicat_Parenthese() throws ParseException {/*@bgen(jjtree) Predicat_parenthese */
  ASTPredicat_parenthese jjtn000 = new ASTPredicat_parenthese(JJTPREDICAT_PARENTHESE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OpenParen);
      Predicat();
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void Predicat_Negation() throws ParseException {/*@bgen(jjtree) Predicat_Negation */
  ASTPredicat_Negation jjtn000 = new ASTPredicat_Negation(JJTPREDICAT_NEGATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Not);
      jj_consume_token(OpenParen);
      Predicat();
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void Predicat_Conjonction() throws ParseException {/*@bgen(jjtree) Predicat_Conjonction */
  ASTPredicat_Conjonction jjtn000 = new ASTPredicat_Conjonction(JJTPREDICAT_CONJONCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        Predicat_Parenthese();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Not:{
        Predicat_Negation();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Forall:{
        Predicat_Universel();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Exists:{
        Predicat_Existentiel();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }
      case EmptySet:
      case Lambda:
      case OpenBraces:
      case Minus:
      case POW:
      case FIN:
      case POW1:
      case FIN1:
      case InterGen:
      case UnionGen:
      case UnionQuant:
      case InterQuant:
      case Id:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case Fnc:
      case Rel:
      case Bool:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:
      case True:
      case False:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case String:
      case Number:{
        Predicat_Egalite();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inegalite();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Appartenance();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Appartenance();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion_Stricte();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion_Stricte();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inferieur_Ou_Egal();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Inferieur();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Superieur_Ou_Egal();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Superieur();
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Predicat_Disjonction() throws ParseException {/*@bgen(jjtree) Predicat_Disjonction */
  ASTPredicat_Disjonction jjtn000 = new ASTPredicat_Disjonction(JJTPREDICAT_DISJONCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        Predicat_Parenthese();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Not:{
        Predicat_Negation();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Forall:{
        Predicat_Universel();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Exists:{
        Predicat_Existentiel();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }
      case EmptySet:
      case Lambda:
      case OpenBraces:
      case Minus:
      case POW:
      case FIN:
      case POW1:
      case FIN1:
      case InterGen:
      case UnionGen:
      case UnionQuant:
      case InterQuant:
      case Id:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case Fnc:
      case Rel:
      case Bool:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:
      case True:
      case False:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case String:
      case Number:{
        Predicat_Egalite();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inegalite();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Appartenance();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Appartenance();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion_Stricte();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion_Stricte();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inferieur_Ou_Egal();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Inferieur();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Superieur_Ou_Egal();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Superieur();
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Predicat_Implication() throws ParseException {/*@bgen(jjtree) Predicat_Implication */
  ASTPredicat_Implication jjtn000 = new ASTPredicat_Implication(JJTPREDICAT_IMPLICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        Predicat_Parenthese();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Not:{
        Predicat_Negation();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Forall:{
        Predicat_Universel();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Exists:{
        Predicat_Existentiel();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }
      case EmptySet:
      case Lambda:
      case OpenBraces:
      case Minus:
      case POW:
      case FIN:
      case POW1:
      case FIN1:
      case InterGen:
      case UnionGen:
      case UnionQuant:
      case InterQuant:
      case Id:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case Fnc:
      case Rel:
      case Bool:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:
      case True:
      case False:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case String:
      case Number:{
        Predicat_Egalite();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inegalite();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Appartenance();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Appartenance();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion_Stricte();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion_Stricte();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inferieur_Ou_Egal();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Inferieur();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Superieur_Ou_Egal();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Superieur();
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Predicat_Equivalence() throws ParseException {/*@bgen(jjtree) Predicat_Equivalence */
  ASTPredicat_Equivalence jjtn000 = new ASTPredicat_Equivalence(JJTPREDICAT_EQUIVALENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        Predicat_Parenthese();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Not:{
        Predicat_Negation();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Forall:{
        Predicat_Universel();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Exists:{
        Predicat_Existentiel();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }
      case EmptySet:
      case Lambda:
      case OpenBraces:
      case Minus:
      case POW:
      case FIN:
      case POW1:
      case FIN1:
      case InterGen:
      case UnionGen:
      case UnionQuant:
      case InterQuant:
      case Id:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case Fnc:
      case Rel:
      case Bool:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:
      case True:
      case False:
      case MaxInt:
      case MinInt:
      case IDENTIFIER:
      case String:
      case Number:{
        Predicat_Egalite();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inegalite();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Appartenance();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Appartenance();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inclusion_Stricte();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Non_Inclusion_Stricte();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Inferieur_Ou_Egal();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Inferieur();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Superieur_Ou_Egal();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }{
        Predicat_Strictement_Superieur();
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Predicat_binaire() throws ParseException {/*@bgen(jjtree) Predicat_binaire */
  ASTPredicat_binaire jjtn000 = new ASTPredicat_binaire(JJTPREDICAT_BINAIRE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case And:{
        jj_consume_token(And);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Union:{
        jj_consume_token(Union);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Implication:{
        jj_consume_token(Implication);
        Predicat();
        Predicat_binaire();
        break;
        }
      case Equivalence:{
        jj_consume_token(Equivalence);
        Predicat();
        Predicat_binaire();
        break;
        }
      default:
        jj_la1[66] = jj_gen;
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;

      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Predicat_Universel() throws ParseException {/*@bgen(jjtree) Predicat_Universel */
  ASTPredicat_Universel jjtn000 = new ASTPredicat_Universel(JJTPREDICAT_UNIVERSEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Forall);
      Liste_ident();
      jj_consume_token(Point);
      jj_consume_token(OpenParen);
      Predicat();
      jj_consume_token(Implication);
      Predicat();
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Existentiel() throws ParseException {/*@bgen(jjtree) Predicat_Existentiel */
  ASTPredicat_Existentiel jjtn000 = new ASTPredicat_Existentiel(JJTPREDICAT_EXISTENTIEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Exists);
      Liste_ident();
      jj_consume_token(Point);
      jj_consume_token(OpenParen);
      Predicat();
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Egalite() throws ParseException {/*@bgen(jjtree) Predicat_Egalite */
  ASTPredicat_Egalite jjtn000 = new ASTPredicat_Egalite(JJTPREDICAT_EGALITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(Equal);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Inegalite() throws ParseException {/*@bgen(jjtree) Predicat_Inegalite */
  ASTPredicat_Inegalite jjtn000 = new ASTPredicat_Inegalite(JJTPREDICAT_INEGALITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(NotEqual);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Appartenance() throws ParseException {/*@bgen(jjtree) Predicat_Appartenance */
  ASTPredicat_Appartenance jjtn000 = new ASTPredicat_Appartenance(JJTPREDICAT_APPARTENANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(In);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Non_Appartenance() throws ParseException {/*@bgen(jjtree) Predicat_Not_Appartenance */
  ASTPredicat_Not_Appartenance jjtn000 = new ASTPredicat_Not_Appartenance(JJTPREDICAT_NOT_APPARTENANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(NotSetMemberShip);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Inclusion() throws ParseException {/*@bgen(jjtree) Predicat_Inclusion */
  ASTPredicat_Inclusion jjtn000 = new ASTPredicat_Inclusion(JJTPREDICAT_INCLUSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(Subset);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Inclusion_Stricte() throws ParseException {/*@bgen(jjtree) Predicat_Insclusion_Stricte */
  ASTPredicat_Insclusion_Stricte jjtn000 = new ASTPredicat_Insclusion_Stricte(JJTPREDICAT_INSCLUSION_STRICTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(StrictSubset);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Non_Inclusion() throws ParseException {/*@bgen(jjtree) Predicat_Non_Inclusion */
  ASTPredicat_Non_Inclusion jjtn000 = new ASTPredicat_Non_Inclusion(JJTPREDICAT_NON_INCLUSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(NotSubset);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Non_Inclusion_Stricte() throws ParseException {/*@bgen(jjtree) Predicat_Non_Inclusion_Stricte */
  ASTPredicat_Non_Inclusion_Stricte jjtn000 = new ASTPredicat_Non_Inclusion_Stricte(JJTPREDICAT_NON_INCLUSION_STRICTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(NotStrictSubset);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Inferieur_Ou_Egal() throws ParseException {/*@bgen(jjtree) Predicat_Inferieur_Ou_Egal */
  ASTPredicat_Inferieur_Ou_Egal jjtn000 = new ASTPredicat_Inferieur_Ou_Egal(JJTPREDICAT_INFERIEUR_OU_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(LessThanOrEqual);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Strictement_Inferieur() throws ParseException {/*@bgen(jjtree) Predicat_Strictement_Inferieur */
  ASTPredicat_Strictement_Inferieur jjtn000 = new ASTPredicat_Strictement_Inferieur(JJTPREDICAT_STRICTEMENT_INFERIEUR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(LessThan);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Strictement_Superieur() throws ParseException {/*@bgen(jjtree) Predicat_Strictement_Superieur */
  ASTPredicat_Strictement_Superieur jjtn000 = new ASTPredicat_Strictement_Superieur(JJTPREDICAT_STRICTEMENT_SUPERIEUR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(GreatherThan);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Predicat_Superieur_Ou_Egal() throws ParseException {/*@bgen(jjtree) Predicat_Superieur_Ou_Egal */
  ASTPredicat_Superieur_Ou_Egal jjtn000 = new ASTPredicat_Superieur_Ou_Egal(JJTPREDICAT_SUPERIEUR_OU_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Expression();
      jj_consume_token(GreatherThanOrEqual);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Expression() throws ParseException {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:
      case IDENTIFIER:
      case String:{
        Expression_primaire();
        ExpressionBis();
        break;
        }
      case Bool:
      case True:
      case False:{
        Expression_booleenne();
        ExpressionBis();
        break;
        }
      case Minus:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case MaxInt:
      case MinInt:
      case Number:{
        Expression_arithmetique();
        ExpressionBis();
        break;
        }
      case EmptySet:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:{
        Expression_d_ensembles();
        ExpressionBis();
        break;
        }
      case Lambda:
      case OpenBraces:
      case POW:
      case FIN:
      case POW1:
      case FIN1:
      case InterGen:
      case UnionGen:
      case UnionQuant:
      case InterQuant:
      case Id:
      case Fnc:
      case Rel:{
        Construction_d_ensembles();
        ExpressionBis();
        break;
        }{
        Expression_de_relations();
        ExpressionBis();
        break;
        }{
        Construction_de_fonctions();
        ExpressionBis();
        break;
        }
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             {if (true) throw (RuntimeException)jjte000;}
           }
           if (jjte000 instanceof ParseException) {
             {if (true) throw (ParseException)jjte000;}
           }
           {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
           }
    }
  }

  final public void ExpressionBis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PartialSurjection:
    case PartialFunction:
    case TotalSurjection:
    case TotalFunction:
    case PartialInjection:
    case TotalBijection:
    case TotalInjection:
    case Maplet:
    case Comma:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PartialFunction:{
        jj_consume_token(PartialFunction);
        break;
        }
      case TotalFunction:{
        jj_consume_token(TotalFunction);
        break;
        }
      case PartialInjection:{
        jj_consume_token(PartialInjection);
        break;
        }
      case TotalInjection:{
        jj_consume_token(TotalInjection);
        break;
        }
      case PartialSurjection:{
        jj_consume_token(PartialSurjection);
        break;
        }
      case TotalSurjection:{
        jj_consume_token(TotalSurjection);
        break;
        }
      case TotalBijection:{
        jj_consume_token(TotalBijection);
        break;
        }
      case Maplet:{
        jj_consume_token(Maplet);
        break;
        }
      case Comma:{
        jj_consume_token(Comma);
        break;
        }
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Expression();
      ExpressionBis();
      break;
      }
    default:
      jj_la1[69] = jj_gen;

    }
  }

  final public void Expression_primaire() throws ParseException {/*@bgen(jjtree) Expression_primaire */
  ASTExpression_primaire jjtn000 = new ASTExpression_primaire(JJTEXPRESSION_PRIMAIRE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        Donnee();
        break;
        }
      case OpenParen:{
        Expr_parenthesee();
        break;
        }
      case String:{
        jj_consume_token(String);
        break;
        }
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Expression_booleenne() throws ParseException {/*@bgen(jjtree) Expression_booleenne */
  ASTExpression_booleenne jjtn000 = new ASTExpression_booleenne(JJTEXPRESSION_BOOLEENNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case True:
      case False:{
        Boolean_lit();
        break;
        }
      case Bool:{
        Conversion_bool();
        break;
        }
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Expression_arithmetique() throws ParseException {/*@bgen(jjtree) ExprArith */
  ASTExprArith jjtn000 = new ASTExprArith(JJTEXPRARITH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MaxInt:
      case MinInt:
      case Number:{
        Entier_lit();
        ExpArithBis();
        break;
        }
      case IDENTIFIER:{
        Ident_ren();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:
        case Quote:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case OpenParen:{
            jj_consume_token(OpenParen);
            Terme();
            label_29:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case Comma:{
                ;
                break;
                }
              default:
                jj_la1[72] = jj_gen;
                break label_29;
              }
              jj_consume_token(Comma);
              Terme();
            }
            jj_consume_token(CloseParen);
            break;
            }
          case Quote:{
            jj_consume_token(Quote);
            jj_consume_token(IDENTIFIER);
            label_30:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case Quote:{
                ;
                break;
                }
              default:
                jj_la1[73] = jj_gen;
                break label_30;
              }
              jj_consume_token(Quote);
              jj_consume_token(IDENTIFIER);
            }
            break;
            }
          default:
            jj_la1[74] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[75] = jj_gen;
          ;
        }
        ExpArithBis();
        break;
        }
      case Minus:{
        jj_consume_token(Minus);
        Expression_arithmetique();
        ExpArithBis();
        break;
        }
      case Succ:{
        jj_consume_token(Succ);
        jj_consume_token(OpenParen);
        Expression_arithmetique();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      case Pred:{
        jj_consume_token(Pred);
        jj_consume_token(OpenParen);
        Expression_arithmetique();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      case OpenParen:{
        jj_consume_token(OpenParen);
        Expression_arithmetique();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      case Max:{
        jj_consume_token(Max);
        jj_consume_token(OpenParen);
        Expression_arithmetique();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      case Min:{
        jj_consume_token(Min);
        jj_consume_token(OpenParen);
        Expression_arithmetique();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      case Card:{
        jj_consume_token(Card);
        jj_consume_token(OpenParen);
        Expression_arithmetique();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      case Sigma:{
        jj_consume_token(Sigma);
        Liste_ident();
        jj_consume_token(Point);
        jj_consume_token(OpenParen);
        Predicat();
        jj_consume_token(SuchAs);
        Expression();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      case Pi:{
        jj_consume_token(Pi);
        Liste_ident();
        jj_consume_token(Point);
        jj_consume_token(OpenParen);
        Predicat();
        jj_consume_token(SuchAs);
        Expression();
        jj_consume_token(CloseParen);
        ExpArithBis();
        break;
        }
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ExpArithBis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case Plus:{
      jj_consume_token(Plus);
      Expression_arithmetique();
      ExpArithBis();
      break;
      }
    case Minus:{
      jj_consume_token(Minus);
      Expression_arithmetique();
      ExpArithBis();
      break;
      }
    case Product:{
      jj_consume_token(Product);
      Expression_arithmetique();
      ExpArithBis();
      break;
      }
    case Division:{
      jj_consume_token(Division);
      Expression_arithmetique();
      ExpArithBis();
      break;
      }
    case Modulo:{
      jj_consume_token(Modulo);
      Expression_arithmetique();
      ExpArithBis();
      break;
      }
    case Power:{
      jj_consume_token(Power);
      Expression_arithmetique();
      ExpArithBis();
      break;
      }
    default:
      jj_la1[77] = jj_gen;

    }
  }

  final public void Expression_d_ensembles() throws ParseException {/*@bgen(jjtree) Expression_d_ensembles */
  ASTExpression_d_ensembles jjtn000 = new ASTExpression_d_ensembles(JJTEXPRESSION_D_ENSEMBLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EmptySet:{
        Ensemble_vide();
        break;
        }
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:{
        Ensemble_entier();
        break;
        }
      case Bool:{
        Ensemble_booleen();
        break;
        }
      case String:{
        Ensemble_chaines();
        break;
        }
      default:
        jj_la1[78] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Construction_d_ensembles() throws ParseException {/*@bgen(jjtree) Construction_d_ensembles */
  ASTConstruction_d_ensembles jjtn000 = new ASTConstruction_d_ensembles(JJTCONSTRUCTION_D_ENSEMBLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenBraces:{
        jj_consume_token(OpenBraces);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          jj_consume_token(IDENTIFIER);
          label_31:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case Comma:{
              ;
              break;
              }
            default:
              jj_la1[79] = jj_gen;
              break label_31;
            }
            jj_consume_token(Comma);
            jj_consume_token(IDENTIFIER);
          }
          jj_consume_token(SuchAs);
          Predicat();
          break;
          }
        case EmptySet:
        case Lambda:
        case OpenBraces:
        case OpenParen:
        case Minus:
        case POW:
        case FIN:
        case POW1:
        case FIN1:
        case InterGen:
        case UnionGen:
        case UnionQuant:
        case InterQuant:
        case Id:
        case Card:
        case Max:
        case Min:
        case Succ:
        case Pred:
        case Sigma:
        case Pi:
        case Fnc:
        case Rel:
        case Bool:
        case Nat:
        case Nat1:
        case Natural:
        case Natural1:
        case Int:
        case Integer:
        case True:
        case False:
        case MaxInt:
        case MinInt:
        case String:
        case Number:{
          Expression();
          label_32:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case Comma:{
              ;
              break;
              }
            default:
              jj_la1[80] = jj_gen;
              break label_32;
            }
            jj_consume_token(Comma);
            Expression();
          }
          break;
          }
        default:
          jj_la1[81] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(CloseBraces);
        ConstrEnsembleBis();
        break;
        }
      case POW:
      case POW1:{
        Sous_ensembles();
        ConstrEnsembleBis();
        break;
        }
      case FIN:
      case FIN1:{
        Sous_ensembles_finis();
        ConstrEnsembleBis();
        break;
        }
      case UnionGen:{
        jj_consume_token(UnionGen);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        break;
        }
      case InterGen:{
        jj_consume_token(InterGen);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        break;
        }
      case UnionQuant:{
        jj_consume_token(UnionQuant);
        Liste_ident();
        jj_consume_token(Point);
        jj_consume_token(OpenParen);
        Predicat();
        jj_consume_token(SuchAs);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        break;
        }
      case InterQuant:{
        jj_consume_token(InterQuant);
        Liste_ident();
        jj_consume_token(Point);
        jj_consume_token(OpenParen);
        Predicat();
        jj_consume_token(SuchAs);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        break;
        }
      case OpenParen:
      case IDENTIFIER:
      case String:{
        Expression_primaire();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Product:{
          jj_consume_token(Product);
          break;
          }
        case In:{
          jj_consume_token(In);
          break;
          }
        case Minus:{
          jj_consume_token(Minus);
          break;
          }
        case Union:{
          jj_consume_token(Union);
          break;
          }
        case Intersection:{
          jj_consume_token(Intersection);
          break;
          }
        default:
          jj_la1[82] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        ConstrEnsembleBis();
        break;
        }
      case Bool:
      case True:
      case False:{
        Expression_booleenne();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Product:{
          jj_consume_token(Product);
          break;
          }
        case In:{
          jj_consume_token(In);
          break;
          }
        case Minus:{
          jj_consume_token(Minus);
          break;
          }
        case Union:{
          jj_consume_token(Union);
          break;
          }
        case Intersection:{
          jj_consume_token(Intersection);
          break;
          }
        default:
          jj_la1[83] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        ConstrEnsembleBis();
        break;
        }
      case Minus:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case MaxInt:
      case MinInt:
      case Number:{
        Expression_arithmetique();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Product:{
          jj_consume_token(Product);
          break;
          }
        case In:{
          jj_consume_token(In);
          break;
          }
        case Minus:{
          jj_consume_token(Minus);
          break;
          }
        case Union:{
          jj_consume_token(Union);
          break;
          }
        case Intersection:{
          jj_consume_token(Intersection);
          break;
          }
        default:
          jj_la1[84] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        ConstrEnsembleBis();
        break;
        }
      case EmptySet:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:{
        Expression_d_ensembles();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Product:{
          jj_consume_token(Product);
          break;
          }
        case In:{
          jj_consume_token(In);
          break;
          }
        case Minus:{
          jj_consume_token(Minus);
          break;
          }
        case Union:{
          jj_consume_token(Union);
          break;
          }
        case Intersection:{
          jj_consume_token(Intersection);
          break;
          }
        default:
          jj_la1[85] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        ConstrEnsembleBis();
        break;
        }
      case Id:{
        Expression_de_relations();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Product:{
          jj_consume_token(Product);
          break;
          }
        case In:{
          jj_consume_token(In);
          break;
          }
        case Minus:{
          jj_consume_token(Minus);
          break;
          }
        case Union:{
          jj_consume_token(Union);
          break;
          }
        case Intersection:{
          jj_consume_token(Intersection);
          break;
          }
        default:
          jj_la1[86] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        ConstrEnsembleBis();
        break;
        }
      case Lambda:
      case Fnc:
      case Rel:{
        Construction_de_fonctions();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Product:{
          jj_consume_token(Product);
          break;
          }
        case In:{
          jj_consume_token(In);
          break;
          }
        case Minus:{
          jj_consume_token(Minus);
          break;
          }
        case Union:{
          jj_consume_token(Union);
          break;
          }
        case Intersection:{
          jj_consume_token(Intersection);
          break;
          }
        default:
          jj_la1[87] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        ConstrEnsembleBis();
        break;
        }
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void ConstrEnsembleBis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PartialSurjection:
    case PartialFunction:
    case TotalSurjection:
    case TotalFunction:
    case PartialInjection:
    case TotalBijection:
    case TotalInjection:
    case Maplet:
    case Union:
    case Intersection:
    case Comma:
    case Minus:
    case Product:
    case In:{
      ExpressionBis();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Product:{
        jj_consume_token(Product);
        break;
        }
      case In:{
        jj_consume_token(In);
        break;
        }
      case Minus:{
        jj_consume_token(Minus);
        break;
        }
      case Union:{
        jj_consume_token(Union);
        break;
        }
      case Intersection:{
        jj_consume_token(Intersection);
        break;
        }
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Expression();
      ConstrEnsembleBis();
      break;
      }
    default:
      jj_la1[90] = jj_gen;

    }
  }

  final public void Expression_de_relations() throws ParseException {/*@bgen(jjtree) Expression_de_relations */
  ASTExpression_de_relations jjtn000 = new ASTExpression_de_relations(JJTEXPRESSION_DE_RELATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Id);
      jj_consume_token(OpenParen);
      Expression();
      jj_consume_token(CloseParen);
      jj_consume_token(Prj1);
      jj_consume_token(OpenParen);
      Expression();
      jj_consume_token(Comma);
      Expression();
      jj_consume_token(CloseParen);
      jj_consume_token(Prj2);
      jj_consume_token(OpenParen);
      Expression();
      jj_consume_token(Comma);
      Expression();
      jj_consume_token(CloseParen);
      jj_consume_token(Dom);
      jj_consume_token(OpenParen);
      Expression();
      jj_consume_token(CloseParen);
      jj_consume_token(Ran);
      jj_consume_token(OpenParen);
      Expression();
      jj_consume_token(CloseParen);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Relation:
      case DomainSubstraction:
      case DomainRestriction:
      case RangeSubstraction:
      case RangeRestriction:
      case Override:
      case DirectProduct:
      case Power:
      case Parallel:
      case SemiColon:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Relation:{
          jj_consume_token(Relation);
          break;
          }
        case SemiColon:{
          jj_consume_token(SemiColon);
          break;
          }
        case DirectProduct:{
          jj_consume_token(DirectProduct);
          break;
          }
        case Parallel:{
          jj_consume_token(Parallel);
          break;
          }
        case Power:{
          jj_consume_token(Power);
          break;
          }
        case DomainRestriction:{
          jj_consume_token(DomainRestriction);
          break;
          }
        case DomainSubstraction:{
          jj_consume_token(DomainSubstraction);
          break;
          }
        case RangeRestriction:{
          jj_consume_token(RangeRestriction);
          break;
          }
        case RangeSubstraction:{
          jj_consume_token(RangeSubstraction);
          break;
          }
        case Override:{
          jj_consume_token(Override);
          break;
          }
        default:
          jj_la1[91] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      case OpenCurly:
      case Tilde:
      case Closure:
      case Closure1:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenCurly:{
          jj_consume_token(OpenCurly);
          Expression();
          jj_consume_token(CloseCurly);
          break;
          }
        case Closure:{
          jj_consume_token(Closure);
          break;
          }
        case Closure1:{
          jj_consume_token(Closure1);
          break;
          }
        case Tilde:{
          jj_consume_token(Tilde);
          break;
          }
        default:
          jj_la1[92] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Construction_de_fonctions() throws ParseException {/*@bgen(jjtree) Construction_de_fonctions */
  ASTConstruction_de_fonctions jjtn000 = new ASTConstruction_de_fonctions(JJTCONSTRUCTION_DE_FONCTIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Lambda:{
        jj_consume_token(Lambda);
        Liste_ident();
        jj_consume_token(Point);
        jj_consume_token(OpenParen);
        Predicat();
        jj_consume_token(SuchAs);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case OpenBraces:{
        jj_consume_token(OpenBraces);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          jj_consume_token(IDENTIFIER);
          label_33:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case Comma:{
              ;
              break;
              }
            default:
              jj_la1[94] = jj_gen;
              break label_33;
            }
            jj_consume_token(Comma);
            jj_consume_token(IDENTIFIER);
          }
          jj_consume_token(SuchAs);
          Predicat();
          break;
          }
        case EmptySet:
        case Lambda:
        case OpenBraces:
        case OpenParen:
        case Minus:
        case POW:
        case FIN:
        case POW1:
        case FIN1:
        case InterGen:
        case UnionGen:
        case UnionQuant:
        case InterQuant:
        case Id:
        case Card:
        case Max:
        case Min:
        case Succ:
        case Pred:
        case Sigma:
        case Pi:
        case Fnc:
        case Rel:
        case Bool:
        case Nat:
        case Nat1:
        case Natural:
        case Natural1:
        case Int:
        case Integer:
        case True:
        case False:
        case MaxInt:
        case MinInt:
        case String:
        case Number:{
          Expression();
          label_34:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case Comma:{
              ;
              break;
              }
            default:
              jj_la1[95] = jj_gen;
              break label_34;
            }
            jj_consume_token(Comma);
            Expression();
          }
          break;
          }
        default:
          jj_la1[96] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(CloseBraces);
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case UnionGen:{
        jj_consume_token(UnionGen);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case InterGen:{
        jj_consume_token(InterGen);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case UnionQuant:{
        jj_consume_token(UnionQuant);
        Liste_ident();
        jj_consume_token(Point);
        jj_consume_token(OpenParen);
        Predicat();
        jj_consume_token(SuchAs);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case InterQuant:{
        jj_consume_token(InterQuant);
        Liste_ident();
        jj_consume_token(Point);
        jj_consume_token(OpenParen);
        Predicat();
        jj_consume_token(SuchAs);
        Expression();
        jj_consume_token(CloseParen);
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case Fnc:{
        jj_consume_token(Fnc);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case Rel:{
        jj_consume_token(Rel);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case POW:
      case POW1:{
        Sous_ensembles();
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case FIN:
      case FIN1:{
        Sous_ensembles_finis();
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case OpenParen:
      case IDENTIFIER:
      case String:{
        Expression_primaire();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:{
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        case Union:
        case Intersection:
        case Minus:
        case Product:
        case In:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Product:{
            jj_consume_token(Product);
            break;
            }
          case In:{
            jj_consume_token(In);
            break;
            }
          case Minus:{
            jj_consume_token(Minus);
            break;
            }
          case Union:{
            jj_consume_token(Union);
            break;
            }
          case Intersection:{
            jj_consume_token(Intersection);
            break;
            }
          default:
            jj_la1[97] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          Expression();
          ConstrEnsembleBis();
          ExpressionBis();
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        default:
          jj_la1[98] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      case Bool:
      case True:
      case False:{
        Expression_booleenne();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:{
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        case Union:
        case Intersection:
        case Minus:
        case Product:
        case In:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Product:{
            jj_consume_token(Product);
            break;
            }
          case In:{
            jj_consume_token(In);
            break;
            }
          case Minus:{
            jj_consume_token(Minus);
            break;
            }
          case Union:{
            jj_consume_token(Union);
            break;
            }
          case Intersection:{
            jj_consume_token(Intersection);
            break;
            }
          default:
            jj_la1[99] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          Expression();
          ConstrEnsembleBis();
          ExpressionBis();
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        default:
          jj_la1[100] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      case Minus:
      case Card:
      case Max:
      case Min:
      case Succ:
      case Pred:
      case Sigma:
      case Pi:
      case MaxInt:
      case MinInt:
      case Number:{
        Expression_arithmetique();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:{
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        case Union:
        case Intersection:
        case Minus:
        case Product:
        case In:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Product:{
            jj_consume_token(Product);
            break;
            }
          case In:{
            jj_consume_token(In);
            break;
            }
          case Minus:{
            jj_consume_token(Minus);
            break;
            }
          case Union:{
            jj_consume_token(Union);
            break;
            }
          case Intersection:{
            jj_consume_token(Intersection);
            break;
            }
          default:
            jj_la1[101] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          Expression();
          ConstrEnsembleBis();
          ExpressionBis();
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        default:
          jj_la1[102] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      case EmptySet:
      case Nat:
      case Nat1:
      case Natural:
      case Natural1:
      case Int:
      case Integer:{
        Expression_d_ensembles();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:{
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        case Union:
        case Intersection:
        case Minus:
        case Product:
        case In:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Product:{
            jj_consume_token(Product);
            break;
            }
          case In:{
            jj_consume_token(In);
            break;
            }
          case Minus:{
            jj_consume_token(Minus);
            break;
            }
          case Union:{
            jj_consume_token(Union);
            break;
            }
          case Intersection:{
            jj_consume_token(Intersection);
            break;
            }
          default:
            jj_la1[103] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          Expression();
          ConstrEnsembleBis();
          ExpressionBis();
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        default:
          jj_la1[104] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      case Id:{
        Expression_de_relations();
        ExpressionBis();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OpenParen:{
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        case Union:
        case Intersection:
        case Minus:
        case Product:
        case In:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Product:{
            jj_consume_token(Product);
            break;
            }
          case In:{
            jj_consume_token(In);
            break;
            }
          case Minus:{
            jj_consume_token(Minus);
            break;
            }
          case Union:{
            jj_consume_token(Union);
            break;
            }
          case Intersection:{
            jj_consume_token(Intersection);
            break;
            }
          default:
            jj_la1[105] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          Expression();
          ConstrEnsembleBis();
          ExpressionBis();
          jj_consume_token(OpenParen);
          Expression();
          jj_consume_token(CloseParen);
          break;
          }
        default:
          jj_la1[106] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void ConstrFonctionBis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PartialSurjection:
    case PartialFunction:
    case TotalSurjection:
    case TotalFunction:
    case PartialInjection:
    case TotalBijection:
    case TotalInjection:
    case Maplet:
    case Union:
    case Intersection:
    case OpenParen:
    case Comma:
    case Minus:
    case Product:
    case In:{
      ExpressionBis();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case Union:
      case Intersection:
      case Minus:
      case Product:
      case In:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Product:{
          jj_consume_token(Product);
          break;
          }
        case In:{
          jj_consume_token(In);
          break;
          }
        case Minus:{
          jj_consume_token(Minus);
          break;
          }
        case Union:{
          jj_consume_token(Union);
          break;
          }
        case Intersection:{
          jj_consume_token(Intersection);
          break;
          }
        default:
          jj_la1[108] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression();
        ConstrEnsembleBis();
        ExpressionBis();
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[109] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ConstrFonctionBis();
      break;
      }
    default:
      jj_la1[110] = jj_gen;

    }
  }

  final public void Expr_parenthesee() throws ParseException {/*@bgen(jjtree) Expr_parenthesee */
  ASTExpr_parenthesee jjtn000 = new ASTExpr_parenthesee(JJTEXPR_PARENTHESEE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OpenParen);
      Expression();
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Conversion_bool() throws ParseException {/*@bgen(jjtree) Conversion_bool */
  ASTConversion_bool jjtn000 = new ASTConversion_bool(JJTCONVERSION_BOOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Bool);
      jj_consume_token(OpenParen);
      Predicat();
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Ensemble_vide() throws ParseException {/*@bgen(jjtree) Ensemble_vide */
  ASTEnsemble_vide jjtn000 = new ASTEnsemble_vide(JJTENSEMBLE_VIDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(EmptySet);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Ensemble_entier() throws ParseException {/*@bgen(jjtree) Ensemble_entier */
  ASTEnsemble_entier jjtn000 = new ASTEnsemble_entier(JJTENSEMBLE_ENTIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Nat:{
        jj_consume_token(Nat);
        break;
        }
      case Nat1:{
        jj_consume_token(Nat1);
        break;
        }
      case Natural:{
        jj_consume_token(Natural);
        break;
        }
      case Natural1:{
        jj_consume_token(Natural1);
        break;
        }
      case Int:{
        jj_consume_token(Int);
        break;
        }
      case Integer:{
        jj_consume_token(Integer);
        break;
        }
      default:
        jj_la1[111] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Ensemble_chaines() throws ParseException {/*@bgen(jjtree) Ensemble_chaines */
  ASTEnsemble_chaines jjtn000 = new ASTEnsemble_chaines(JJTENSEMBLE_CHAINES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(String);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Ensemble_booleen() throws ParseException {/*@bgen(jjtree) Ensemble_booleen */
  ASTEnsemble_booleen jjtn000 = new ASTEnsemble_booleen(JJTENSEMBLE_BOOLEEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Bool);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Sous_ensembles() throws ParseException {/*@bgen(jjtree) Sous_ensembles */
  ASTSous_ensembles jjtn000 = new ASTSous_ensembles(JJTSOUS_ENSEMBLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case POW:{
        jj_consume_token(POW);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case POW1:{
        jj_consume_token(POW1);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[112] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Sous_ensembles_finis() throws ParseException {/*@bgen(jjtree) Sous_ensembles_finis */
  ASTSous_ensembles_finis jjtn000 = new ASTSous_ensembles_finis(JJTSOUS_ENSEMBLES_FINIS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FIN:{
        jj_consume_token(FIN);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      case FIN1:{
        jj_consume_token(FIN1);
        jj_consume_token(OpenParen);
        Expression();
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public void Substitution() throws ParseException {/*@bgen(jjtree) Substitution */
  ASTSubstitution jjtn000 = new ASTSubstitution(JJTSUBSTITUTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Begin:{
        Substitution_bloc();
        break;
        }
      case Skip:{
        Substitution_identite();
        break;
        }
      case IDENTIFIER:{
        Substitution_devient_egal();
        break;
        }
      case Pre:{
        Substitution_precondition();
        break;
        }
      case Assert:{
        Substitution_assertion();
        break;
        }
      case Choice:{
        Substitution_choix_borne();
        break;
        }
      case If:{
        Substitution_conditionnelle();
        break;
        }
      case Select:{
        Substitution_selection();
        break;
        }
      case Case:{
        Substitution_cas();
        break;
        }
      case Any:{
        Substitution_choix_non_borne();
        break;
        }
      case Let:{
        Substitution_definition_locale();
        break;
        }{
        Substitution_devient_elt_de();
        break;
        }{
        Substitution_devient_tel_que();
        break;
        }
      case Var:{
        Substitution_variable_locale();
        break;
        }
      case While:{
        Substitution_sequence();
        break;
        }{
        Substitution_appel_operation();
        break;
        }{
        Substitution_simultanee();
        break;
        }{
        Substitution_tant_que();
        break;
        }
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_corps_operation() throws ParseException {/*@bgen(jjtree) Substitution_corps_operation */
  ASTSubstitution_corps_operation jjtn000 = new ASTSubstitution_corps_operation(JJTSUBSTITUTION_CORPS_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Begin:{
        Substitution_bloc();
        break;
        }
      case Skip:{
        Substitution_identite();
        break;
        }
      case IDENTIFIER:{
        Substitution_devient_egal();
        break;
        }
      case Pre:{
        Substitution_precondition();
        break;
        }
      case Assert:{
        Substitution_assertion();
        break;
        }
      case Choice:{
        Substitution_choix_borne();
        break;
        }
      case If:{
        Substitution_conditionnelle();
        break;
        }
      case Select:{
        Substitution_selection();
        break;
        }
      case Case:{
        Substitution_cas();
        break;
        }
      case Any:{
        Substitution_choix_non_borne();
        break;
        }
      case Let:{
        Substitution_definition_locale();
        break;
        }{
        Substitution_devient_elt_de();
        break;
        }{
        Substitution_devient_tel_que();
        break;
        }
      case Var:{
        Substitution_variable_locale();
        break;
        }{
        Substitution_appel_operation();
        break;
        }
      default:
        jj_la1[115] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_bloc() throws ParseException {/*@bgen(jjtree) Substitution_bloc */
  ASTSubstitution_bloc jjtn000 = new ASTSubstitution_bloc(JJTSUBSTITUTION_BLOC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Begin);
      Substitution();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_identite() throws ParseException {/*@bgen(jjtree) Substitution_identite */
  ASTSubstitution_identite jjtn000 = new ASTSubstitution_identite(JJTSUBSTITUTION_IDENTITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Skip);
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_devient_egal() throws ParseException {/*@bgen(jjtree) Substitution_devient_egal */
  ASTSubstitution_devient_egal jjtn000 = new ASTSubstitution_devient_egal(JJTSUBSTITUTION_DEVIENT_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Ident_ren();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DevientEgal:
      case Comma:{
        label_35:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[116] = jj_gen;
            break label_35;
          }
          jj_consume_token(Comma);
          Ident_ren();
        }
        jj_consume_token(DevientEgal);
        Expression();
        label_36:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[117] = jj_gen;
            break label_36;
          }
          jj_consume_token(Comma);
          Expression();
        }
        break;
        }
      case OpenParen:{
        jj_consume_token(OpenParen);
        Expression();
        label_37:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[118] = jj_gen;
            break label_37;
          }
          jj_consume_token(Comma);
          Expression();
        }
        jj_consume_token(CloseParen);
        jj_consume_token(DevientEgal);
        Expression();
        break;
        }
      case Quote:{
        jj_consume_token(Quote);
        jj_consume_token(IDENTIFIER);
        label_38:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Quote:{
            ;
            break;
            }
          default:
            jj_la1[119] = jj_gen;
            break label_38;
          }
          jj_consume_token(Quote);
          jj_consume_token(IDENTIFIER);
        }
        jj_consume_token(DevientEgal);
        Expression();
        break;
        }
      default:
        jj_la1[120] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_precondition() throws ParseException {/*@bgen(jjtree) Substitution_precondition */
  ASTSubstitution_precondition jjtn000 = new ASTSubstitution_precondition(JJTSUBSTITUTION_PRECONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Pre);
      Predicat();
      jj_consume_token(Then);
      Substitution();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_assertion() throws ParseException {/*@bgen(jjtree) Substitution_assertion */
  ASTSubstitution_assertion jjtn000 = new ASTSubstitution_assertion(JJTSUBSTITUTION_ASSERTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Assert);
      Predicat();
      jj_consume_token(Then);
      Substitution();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_choix_borne() throws ParseException {/*@bgen(jjtree) Substitution_choix_borne */
  ASTSubstitution_choix_borne jjtn000 = new ASTSubstitution_choix_borne(JJTSUBSTITUTION_CHOIX_BORNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Choice);
      Substitution();
      label_39:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OrC:{
          ;
          break;
          }
        default:
          jj_la1[121] = jj_gen;
          break label_39;
        }
        jj_consume_token(OrC);
        Substitution();
      }
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_conditionnelle() throws ParseException {/*@bgen(jjtree) Substitution_conditionnelle */
  ASTSubstitution_conditionnelle jjtn000 = new ASTSubstitution_conditionnelle(JJTSUBSTITUTION_CONDITIONNELLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(If);
      Predicat();
      jj_consume_token(Then);
      Substitution();
      label_40:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Elsif:{
          ;
          break;
          }
        default:
          jj_la1[122] = jj_gen;
          break label_40;
        }
        jj_consume_token(Elsif);
        Predicat();
        jj_consume_token(Then);
        Substitution();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Else:{
        jj_consume_token(Else);
        Substitution();
        break;
        }
      default:
        jj_la1[123] = jj_gen;
        ;
      }
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_selection() throws ParseException {/*@bgen(jjtree) Substitution_selection */
  ASTSubstitution_selection jjtn000 = new ASTSubstitution_selection(JJTSUBSTITUTION_SELECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Select);
      Predicat();
      jj_consume_token(Then);
      Substitution();
      label_41:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case When:{
          ;
          break;
          }
        default:
          jj_la1[124] = jj_gen;
          break label_41;
        }
        jj_consume_token(When);
        Predicat();
        jj_consume_token(Then);
        Substitution();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Else:{
        jj_consume_token(Else);
        Substitution();
        break;
        }
      default:
        jj_la1[125] = jj_gen;
        ;
      }
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_cas() throws ParseException {/*@bgen(jjtree) Substitution_cas */
  ASTSubstitution_cas jjtn000 = new ASTSubstitution_cas(JJTSUBSTITUTION_CAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Case);
      Expression();
      jj_consume_token(Of);
      jj_consume_token(Either);
      Terme_simple();
      label_42:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[126] = jj_gen;
          break label_42;
        }
        jj_consume_token(Comma);
        Terme_simple();
      }
      jj_consume_token(Then);
      Substitution();
      label_43:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OrC:{
          ;
          break;
          }
        default:
          jj_la1[127] = jj_gen;
          break label_43;
        }
        jj_consume_token(OrC);
        Terme_simple();
        label_44:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[128] = jj_gen;
            break label_44;
          }
          jj_consume_token(Comma);
          Terme_simple();
        }
        jj_consume_token(Then);
        Substitution();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Else:{
        jj_consume_token(Else);
        Substitution();
        break;
        }
      default:
        jj_la1[129] = jj_gen;
        ;
      }
      jj_consume_token(End);
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_choix_non_borne() throws ParseException {/*@bgen(jjtree) Substitution_choix_non_borne */
  ASTSubstitution_choix_non_borne jjtn000 = new ASTSubstitution_choix_non_borne(JJTSUBSTITUTION_CHOIX_NON_BORNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Any);
      jj_consume_token(IDENTIFIER);
      label_45:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[130] = jj_gen;
          break label_45;
        }
        jj_consume_token(Comma);
        jj_consume_token(IDENTIFIER);
      }
      jj_consume_token(Where);
      Predicat();
      jj_consume_token(Then);
      Substitution();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_definition_locale() throws ParseException {/*@bgen(jjtree) Substitution_definition_locale */
  ASTSubstitution_definition_locale jjtn000 = new ASTSubstitution_definition_locale(JJTSUBSTITUTION_DEFINITION_LOCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Let);
      jj_consume_token(IDENTIFIER);
      label_46:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[131] = jj_gen;
          break label_46;
        }
        jj_consume_token(Comma);
        jj_consume_token(IDENTIFIER);
      }
      jj_consume_token(Be);
      jj_consume_token(IDENTIFIER);
      jj_consume_token(Equal);
      Expression();
      label_47:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ConcatSequence:{
          ;
          break;
          }
        default:
          jj_la1[132] = jj_gen;
          break label_47;
        }
        jj_consume_token(ConcatSequence);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(Equal);
        Expression();
      }
      jj_consume_token(InLetVar);
      Substitution();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_devient_elt_de() throws ParseException {/*@bgen(jjtree) Substitution_devient_elt_de */
  ASTSubstitution_devient_elt_de jjtn000 = new ASTSubstitution_devient_elt_de(JJTSUBSTITUTION_DEVIENT_ELT_DE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Ident_ren();
      label_48:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[133] = jj_gen;
          break label_48;
        }
        jj_consume_token(Comma);
        jj_consume_token(IDENTIFIER);
      }
      jj_consume_token(SetIn);
      Expression();
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_devient_tel_que() throws ParseException {/*@bgen(jjtree) Substitution_devient_tel_que */
  ASTSubstitution_devient_tel_que jjtn000 = new ASTSubstitution_devient_tel_que(JJTSUBSTITUTION_DEVIENT_TEL_QUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Ident_ren();
      label_49:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[134] = jj_gen;
          break label_49;
        }
        jj_consume_token(Comma);
        Ident_ren();
      }
      jj_consume_token(In);
      jj_consume_token(OpenParen);
      Predicat();
      jj_consume_token(CloseParen);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_variable_locale() throws ParseException {/*@bgen(jjtree) Substitution_variable_locale */
  ASTSubstitution_variable_locale jjtn000 = new ASTSubstitution_variable_locale(JJTSUBSTITUTION_VARIABLE_LOCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(Var);
      jj_consume_token(IDENTIFIER);
      label_50:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case Comma:{
          ;
          break;
          }
        default:
          jj_la1[135] = jj_gen;
          break label_50;
        }
        jj_consume_token(Comma);
        Ident_ren();
      }
      jj_consume_token(InLetVar);
      Substitution();
      jj_consume_token(End);
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_sequence() throws ParseException {/*@bgen(jjtree) Substitution_sequence */
  ASTSubstitution_sequence jjtn000 = new ASTSubstitution_sequence(JJTSUBSTITUTION_SEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Begin:{
        Substitution_bloc();
        Substitution_binaire();
        break;
        }
      case Skip:{
        Substitution_identite();
        Substitution_binaire();
        break;
        }
      case IDENTIFIER:{
        Substitution_devient_egal();
        Substitution_binaire();
        break;
        }
      case Pre:{
        Substitution_precondition();
        Substitution_binaire();
        break;
        }
      case Assert:{
        Substitution_assertion();
        Substitution_binaire();
        break;
        }
      case Choice:{
        Substitution_choix_borne();
        Substitution_binaire();
        break;
        }
      case If:{
        Substitution_conditionnelle();
        Substitution_binaire();
        break;
        }
      case Select:{
        Substitution_selection();
        Substitution_binaire();
        break;
        }
      case Case:{
        Substitution_cas();
        Substitution_binaire();
        break;
        }
      case Any:{
        Substitution_choix_non_borne();
        Substitution_binaire();
        break;
        }
      case Let:{
        Substitution_definition_locale();
        Substitution_binaire();
        break;
        }{
        Substitution_devient_elt_de();
        Substitution_binaire();
        break;
        }{
        Substitution_devient_tel_que();
        Substitution_binaire();
        break;
        }
      case Var:{
        Substitution_variable_locale();
        Substitution_binaire();
        break;
        }{
        Substitution_appel_operation();
        Substitution_binaire();
        break;
        }
      case While:{
        Substitution_tant_que();
        Substitution_binaire();
        break;
        }
      default:
        jj_la1[136] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_appel_operation() throws ParseException {/*@bgen(jjtree) Substitution_appel_operation */
  ASTSubstitution_appel_operation jjtn000 = new ASTSubstitution_appel_operation(JJTSUBSTITUTION_APPEL_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        Ident_ren();
        label_51:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[137] = jj_gen;
            break label_51;
          }
          jj_consume_token(Comma);
          Ident_ren();
        }
        jj_consume_token(OperationReturn);
        break;
        }
      default:
        jj_la1[138] = jj_gen;
        ;
      }
      Ident_ren();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OpenParen:{
        jj_consume_token(OpenParen);
        Expression();
        label_52:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[139] = jj_gen;
            break label_52;
          }
          jj_consume_token(Comma);
          Expression();
        }
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[140] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_simultanee() throws ParseException {/*@bgen(jjtree) Substitution_simultanee */
  ASTSubstitution_simultanee jjtn000 = new ASTSubstitution_simultanee(JJTSUBSTITUTION_SIMULTANEE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Begin:{
        Substitution_bloc();
        Substitution_binaire();
        break;
        }
      case Skip:{
        Substitution_identite();
        Substitution_binaire();
        break;
        }
      case IDENTIFIER:{
        Substitution_devient_egal();
        Substitution_binaire();
        break;
        }
      case Pre:{
        Substitution_precondition();
        Substitution_binaire();
        break;
        }
      case Assert:{
        Substitution_assertion();
        Substitution_binaire();
        break;
        }
      case Choice:{
        Substitution_choix_borne();
        Substitution_binaire();
        break;
        }
      case If:{
        Substitution_conditionnelle();
        Substitution_binaire();
        break;
        }
      case Select:{
        Substitution_selection();
        Substitution_binaire();
        break;
        }
      case Case:{
        Substitution_cas();
        Substitution_binaire();
        break;
        }
      case Any:{
        Substitution_choix_non_borne();
        Substitution_binaire();
        break;
        }
      case Let:{
        Substitution_definition_locale();
        Substitution_binaire();
        break;
        }{
        Substitution_devient_elt_de();
        Substitution_binaire();
        break;
        }{
        Substitution_devient_tel_que();
        Substitution_binaire();
        break;
        }
      case Var:{
        Substitution_variable_locale();
        Substitution_binaire();
        break;
        }{
        Substitution_appel_operation();
        Substitution_binaire();
        break;
        }
      case While:{
        Substitution_tant_que();
        Substitution_binaire();
        break;
        }
      default:
        jj_la1[141] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Substitution_binaire() throws ParseException {/*@bgen(jjtree) Substitution_binaire */
  ASTSubstitution_binaire jjtn000 = new ASTSubstitution_binaire(JJTSUBSTITUTION_BINAIRE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SemiColon:{
        jj_consume_token(SemiColon);
        Substitution();
        break;
        }
      case Parallel:{
        jj_consume_token(Parallel);
        Substitution();
        break;
        }
      default:
        jj_la1[142] = jj_gen;
jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;

      }
    } catch (Throwable jjte000) {
if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Liste_ident() throws ParseException {/*@bgen(jjtree) Liste_ident */
  ASTListe_ident jjtn000 = new ASTListe_ident(JJTLISTE_IDENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        break;
        }
      case OpenParen:{
        jj_consume_token(OpenParen);
        jj_consume_token(IDENTIFIER);
        label_53:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case Comma:{
            ;
            break;
            }
          default:
            jj_la1[143] = jj_gen;
            break label_53;
          }
          jj_consume_token(Comma);
          jj_consume_token(IDENTIFIER);
        }
        jj_consume_token(CloseParen);
        break;
        }
      default:
        jj_la1[144] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public void Ensemble_simple() throws ParseException {/*@bgen(jjtree) Ensemble_simple */
  ASTEnsemble_simple jjtn000 = new ASTEnsemble_simple(JJTENSEMBLE_SIMPLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case Bool:{
        jj_consume_token(Bool);
        break;
        }
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        break;
        }
      default:
        jj_la1[145] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  /** Generated Token Manager. */
  public ParserBTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[146];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x1fed80,0x1fed80,0x0,0x0,0x0,0x0,0x0,0x0,0x44000,0x0,0x0,0x0,0x0,0x0,0x20400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2800200,0x2800200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2800200,0x0,0x8000000,0x10000000,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa3800200,0xa3800200,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0xa3800200,0x0,0x0,0x0,0x0,0xa3800200,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3800000,0x0,0x0,0x640,0x640,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x640,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x2000,0x2000,0x2000,0x2000,0x90000,0x2000,0x78000000,0x78000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x78000000,0x4000000,0x0,0x4000000,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x78000000,0x0,0x0,0x0,0x654,0x254,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x20,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x654,0x0,0x0,0x0,0x0,0x654,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x80000000,0x0,0x0,0x0,0x0,0x21000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x20000000,0x80,0x0,0x80,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2d000000,0x2d000000,0x2d000000,0x2d000000,0x2d000000,0x400000,0x21000000,0x87,0x87,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x21000000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0x21000000,0xc00000,0xc00087,0x203f00,0x10000020,0x10203f20,0x0,0x0,0x21000000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0xc00000,0x21000000,0xc00000,0xc00000,0xc00087,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x4,0x1,0xfc000081,0x400000,0x4,0x1000,0x0,0x4,0x4,0x400000,0x81,0x4,0x0,0x4,0x400000,0x400000,0x0,0x4,0x1,0x1,0x81,0x1,0x0,0x0,0x0,0x0,0x81,0x4,0x0,0x81,0x0,0x4,0x0,0x0,0xd000,0x21,0x18,0x40,0x40,0x4,0x4,0x1,0x800000,0x800001,0x4,0x0,0x81,0x4,0x81,0x1,0x40,0x400000,0x0,0x0,0x4,0x8,0x4,0x0,0xfc0000a1,0xfc0000a1,0xfc0000a1,0xfc0000a1,0xfc0000a1,0x10,0xfc000081,0x4,0x4,0x1,0x0,0x4,0x800000,0x800001,0x800001,0x81,0xf80,0x0,0x4,0x4,0xfc000081,0x10280,0x10280,0x10280,0x10280,0x10280,0x10280,0xfc000081,0x10280,0x10284,0x600000,0x0,0x600000,0x4,0x4,0xfc000081,0x10280,0x10281,0x10280,0x10281,0x10280,0x10281,0x10280,0x10281,0x10280,0x10281,0xfc000081,0x10280,0x10281,0x10285,0x0,0x14000000,0x28000000,0x40,0x40,0x4,0x4,0x4,0x800000,0x800005,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x0,0x4,0x4,0x2000,0x4,0x4,0x4,0x40,0x4,0x0,0x4,0x1,0x40,0x600000,0x4,0x1,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0xb8007f07,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa0007f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20007f00,0x0,0x0,0x0,0x0,0x0,0xa0007f00,0x0,0x0,0xa0007f00,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20007f00,0x0,0x20007f00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x98007f07,0x98007f07,0x98007f07,0x98007f07,0x98007f07,0x0,0x98007f07,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x7f00,0x0,0x80000000,0x0,0x0,0x98007f07,0x0,0x0,0x0,0x0,0x0,0x0,0x98007f07,0x0,0x0,0x0,0xc0,0xc0,0x0,0x0,0x98007f07,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x98007f07,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0xc0000dff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000dc0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x40000dc0,0x0,0x40000dc0,0xc00,0xc0,0x40000000,0x40000dc0,0x0,0x40000000,0x40000dc0,0x0,0x0,0x0,0x40000000,0x0,0x40000dc0,0x0,0x40000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0xc0000dc0,0x0,0xc0000dc0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000cff,0xc0000cff,0xc0000cff,0xc0000cff,0xc0000cff,0x0,0xc0000cff,0x0,0x0,0xc0000000,0xc0,0x0,0x0,0x0,0x0,0x40000c00,0x0,0x8000003f,0x0,0x0,0xc0000cff,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000cff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000cff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000cff,0x0,0x0,0x0,0x3f,0x0,0x0,0x40000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x40000000,0x0,0x0,0x40000000,0x0,0x0,0x40000000,0x40000000,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x1,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0x1,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public ParserB(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ParserB(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserBTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 146; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 146; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ParserB(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserBTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 146; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 146; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ParserB(ParserBTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 146; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ParserBTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 146; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[193];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 146; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 193; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
