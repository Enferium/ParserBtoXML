/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parserB.jj */
/*@egen*/options {
	STATIC = false;
	             
	                                       
	                       
	             
	LOOKAHEAD = 3;
	FORCE_LA_CHECK = true;
}


PARSER_BEGIN(ParserB)

package grammaire ;

import java.io.*;
import java.util.*;

public class ParserB/*@bgen(jjtree)*/implements ParserBTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserBState jjtree = new JJTParserBState();

/*@egen*/


}

PARSER_END(ParserB)


SKIP : {
  < [" ", "\t", "\n", "\r", "\u00a0"] >
}

SKIP : {
	"/*" : WithinComment
}

<WithinComment> SKIP : {
	"*/" : DEFAULT
}

<WithinComment> MORE:
{
  < ~[] >
}

TOKEN : {

  	<Machine: "MACHINE">
|  	<End : "END">
|  	<Sets : "SETS">
|  	<Invariant : "INVARIANT">
|  	<Assert : "ASSERT">
|  	<Variables : "VARIABLES">
|  	<Operations : "OPERATIONS">
| 	<Events : "EVENTS">
|	<Constraints : "CONSTRAINTS">
|	<Constants : "CONSTANTS">
|	<Properties : "PROPERTIES">
|	<ConcreteVariables : "CONCRETE_VARIABLES">
|	<AbstractVariables : "ABSTRACT_VARIABLES">
|	<ConcreteConstants : "CONCRETE_CONSTANTS">
|	<AbstractConstants : "ABSTRACT_CONSTANTS">
|	<Initialisation : "INITIALISATION" >
|	<Definitions : "DEFINITIONS">
|	<Values : "VALUES">
|	<Begin : "BEGIN">
|	<Pre : "PRE">
|	<If : "IF">
|	<Then : "THEN">
|	<Elsif : "ELSIF">
|	<Else : "ELSE">
|	<Any : "ANY">
|	<Where : "WHERE">
|	<Let : "LET">
|	<Be : "BE">
|	<InLetVar : "IN">
|	<Choice : "CHOICE">
|	<OrC : "OR">
|	<Select : "SELECT">
|	<When : "WHEN">
|	<Case : "CASE">
|	<Of : "OF">
|	<Either : "EITHER">
|	<Var : "VAR">
|	<While : "WHILE">
|	<Do : "DO">
|	<Variant : "VARIANT">

|	<EmptySet : "{" (" ")* "}">
|	<EmptySequence : "[" (" ")* "]">
|	<EmptySequenceOld : "<>">


|	<Equivalence : "<=>">
|	<Subset : "<:">
|	<NotSubset : "/<:">
|	<Implication : "=>">
|	<StrictSubset : "<<:">
|	<NotStrictSubset : "/<<:">
|	<NotSetMemberShip : "/:">
|	<NotEqual : "/=">

|	<LessThanOrEqual : "<=">
|	<GreatherThanOrEqual : ">=">


|	<Relation : "<->">
|	<PartialSurjection : "+->>">
|	<PartialFunction: "+->">
|	<TotalSurjection : "-->>">
|	<TotalFunction : "-->">
|	<PartialBijection : ">+>>">
|	<PartialInjection : ">+>">
|	<TotalBijection : ">->>">
|	<TotalInjection : ">->">

|	<OperationReturn : "<--">
|	<DevientEgal : ":=">

|	<OpenCurly : "[">
|	<CloseCurly : "]">

|	<Maplet : "|->">

|	<DomainSubstraction : "<<|">
|	<DomainRestriction : "<|">
|	<RangeSubstraction : "|>>">
|	<RangeRestriction : "|>">
|	<Override : "<+">
|	<DirectProduct : "><">
|	<PrependSequence : "->">
|	<AppendSequence : "<-">
|	<PrefixSequence : "/|\\">
|	<SuffixSequence : "\\|/">

|	<SetIn : "::">
|	<EqualEqual : "==">
|	<NatRange : "..">
|	<Power : "**">

|	<Union : "\\/">
|	<Intersection : "/\\">

|	<Lambda : "%">
|	<SuchAs : "|">
|	<Forall : "!">
|	<Exists : "#">
|	<Tilde : "~">
|	<OpenBraces : "{">
|	<CloseBraces : "}">
|  	<Point : ".">
|  	<OpenParen : "(">
|  	<CloseParen : ")">
|	<Comma : ",">
|	<Or : "or">
|	<And  : "&">
|	<Not : "not">
|	<Skip : "skip">
|	<Minus : "-">
|	<Plus : "+">
|	<Product : "*">
|	<Division : "/">
|	<Modulo : "mod">
|	<Equal : "=">
|	<ConcatSequence : "^">
|	<LessThan : "<">
|	<GreatherThan : ">">

|	<In : ":">
|	<DollarZero : "$0">

| 	<Composition : "\u00b0">
|	<ParallelProduct : "//">
|	<SetMinus : "\\">

|	<Parallel : "||">
|	<SemiColon : ";">
|	<Quote : "'">

|	<Prj1 : "prj1">
|	<Prj2 : "prj2">
|	<POW : "POW">
|	<FIN : "FIN">
|	<POW1 : "POW1">
|	<FIN1 : "FIN1">
|	<InterGen : "inter">
|	<UnionGen : "union">
|	<UnionQuant : "UNION">
|	<InterQuant : "INTER">
|	<Id : "id">
|	<Dom : "dom">
|	<Ran : "ran">
|	<Iterate : "iterate">
|	<Closure : "closure">
|	<Closure1 : "closure1">
|	<Card : "card">
|	<Max : "max">
|	<Min : "min">
|   <Succ : "succ">
|	<Pred : "pred">
|	<Sigma : "SIGMA">
|	<Pi : "PI">
|	<Seq : "seq">
|	<Iseq : "iseq">
|	<Seq1 : "seq1">
|	<Iseq1 : "iseq1">
|	<Perm : "perm">
|	<Conc : "conc">
|	<Front : "front">
|	<Tail : "tail">
|	<First : "first">
|	<Last : "last">
|	<Size : "size">
|	<Rev : "rev">
|	<Fnc : "fnc">
|	<Rel : "rel">
|	<Rec : "rec">
|	<Struct : "struct">
|	<Bool : "bool">

|	<Nat : "NAT">
|	<Nat1 : "NAT1">
|	<Natural : "NATURAL">
|	<Natural1 : "NATURAL1">
|	<Int : "INT">
|	<Integer : "INTEGER">
|	<True : "TRUE">
|	<False : "FALSE">
|	<Boolean : "BOOL">
|	<StringSet : "STRING">
|	<MaxInt : "MAXINT">
|	<MinInt : "MININT">

| 	<Tree : "tree" >
| 	<Btree : "btree" >
| 	<Const : "const" > 
| 	<Top : "top" >
| 	<Sons : "sons" >
| 	< Prefix : "prefix"> 
| 	< Postfix : "postfix"> 
| 	< Sizet : "sizet" >
| 	< Mirror : "mirror" >
| 	< Rank : "rank" >
| 	< Father : "father" >
| 	< Son : "son" >
| 	< Subtree : "subtree" >
| 	< Arity : "arity" >
| 	< Bin : "bin" >
| 	< Left : "left" >
| 	< Right : "right" >
| 	< Infix : "infix" >
}

TOKEN : {
	<IDENTIFIER : ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_","0"-"9"])*>
}

TOKEN : {
	<String:
      		"\""
      		(         (~["\"","\\","\n","\r"])
        		| ("\\"
            			(   ["n","t","b","r","f","\\","'","\""]
            			  | ["0"-"7"] ( ["0"-"7"] )?
            			  | ["0"-"3"] ["0"-"7"] ["0"-"7"]
           			)
          		  )
      		)*
          	"\""
  	>
}

TOKEN : {
	<Number : (["0"-"9"])+ >
}

ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Start */
  try {
/*@egen*/
  Composant()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Donnee() : { } {
	Ident_ren()
}

void Ident_ren()            : {/*@bgen(jjtree) Ident_ren */
  ASTIdent_ren jjtn000 = new ASTIdent_ren(JJTIDENT_REN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Ident_ren */
   try {
/*@egen*/
   < IDENTIFIER > (< Point > < IDENTIFIER > )*/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void Composant() : {} {
   Machine_abstraite ()
}

void Machine_abstraite ()          : {/*@bgen(jjtree) Machine */
  ASTMachine jjtn000 = new ASTMachine(JJTMACHINE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Machine */
        try {
/*@egen*/
	<Machine> EnTete() (Clause_machine_abstraite())* <End>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_machine_abstraite() : {} {
	Clause_constraints()
	|  Clause_sets()
	|  Clause_concrete_constants()
	|  Clause_abstract_constants()
	|  Clause_properties()
	|  Clause_concrete_variables()
	|  Clause_abstract_variables()
	|  Clause_invariant()
	|  Clause_initialisation()
	|  Clause_operations()
}

void EnTete()         : {/*@bgen(jjtree) EnTete */
  ASTEnTete jjtn000 = new ASTEnTete(JJTENTETE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) EnTete */
        try {
/*@egen*/
	<IDENTIFIER> [<OpenParen> <IDENTIFIER>(<Comma> <IDENTIFIER>)* <CloseParen>]/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_constraints ()              : {/*@bgen(jjtree) Constraints */
  ASTConstraints jjtn000 = new ASTConstraints(JJTCONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Constraints */
        try {
/*@egen*/
	<Constraints> Predicat()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Instanciation() : {} {
		Terme()
	|   Ensemble_entier() 
	|  	<Boolean>
	|  	Expression() < In > Expression() 
}

void Clause_sets ()       : {/*@bgen(jjtree) Sets */
  ASTSets jjtn000 = new ASTSets(JJTSETS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Sets */
        try {
/*@egen*/
	<Sets> Ensemble() (<SemiColon> Ensemble())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Ensemble()           : {/*@bgen(jjtree) Ensemble */
  ASTEnsemble jjtn000 = new ASTEnsemble(JJTENSEMBLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Ensemble */
  try {
/*@egen*/
  <IDENTIFIER> [<Equal> <OpenBraces> <IDENTIFIER> (<Comma> <IDENTIFIER>)*  <CloseBraces>]/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Clause_concrete_constants()                    : {/*@bgen(jjtree) ConcreteConstants */
  ASTConcreteConstants jjtn000 = new ASTConcreteConstants(JJTCONCRETECONSTANTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ConcreteConstants */
        try {
/*@egen*/
	(<ConcreteConstants> | <Constants> ) <IDENTIFIER> (<Comma> <IDENTIFIER>)*/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_abstract_constants()                    : {/*@bgen(jjtree) AbstractConstants */
  ASTAbstractConstants jjtn000 = new ASTAbstractConstants(JJTABSTRACTCONSTANTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AbstractConstants */
        try {
/*@egen*/
	<AbstractConstants> <IDENTIFIER> (<Comma> <IDENTIFIER>)*/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_properties()             : {/*@bgen(jjtree) Properties */
  ASTProperties jjtn000 = new ASTProperties(JJTPROPERTIES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Properties */
        try {
/*@egen*/
	<Properties> Predicat()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_values()         : {/*@bgen(jjtree) Values */
  ASTValues jjtn000 = new ASTValues(JJTVALUES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Values */
        try {
/*@egen*/
	<Values> Valuation() (<SemiColon> Valuation())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Valuation()        : {/*@bgen(jjtree) Value */
  ASTValue jjtn000 = new ASTValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Value */
        try {
/*@egen*/
	< IDENTIFIER > <Equal> (Terme() | Expr_tableau())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_concrete_variables()                    : {/*@bgen(jjtree) ConcreteVariables */
  ASTConcreteVariables jjtn000 = new ASTConcreteVariables(JJTCONCRETEVARIABLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ConcreteVariables */
        try {
/*@egen*/
	<ConcreteVariables> Ident_ren() (<Comma> Ident_ren())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_abstract_variables()                    : {/*@bgen(jjtree) AbstractVariables */
  ASTAbstractVariables jjtn000 = new ASTAbstractVariables(JJTABSTRACTVARIABLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) AbstractVariables */
        try {
/*@egen*/
	(<AbstractVariables> | <Variables>) Ident_ren() (<Comma> Ident_ren())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_invariant()            : {/*@bgen(jjtree) Invariant */
  ASTInvariant jjtn000 = new ASTInvariant(JJTINVARIANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Invariant */
        try {
/*@egen*/
	<Invariant> Predicat()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_initialisation()                 : {/*@bgen(jjtree) Initialisation */
  ASTInitialisation jjtn000 = new ASTInitialisation(JJTINITIALISATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Initialisation */
        try {
/*@egen*/
	<Initialisation> Substitution()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Clause_operations()              : {/*@bgen(jjtree) Operations */
  ASTOperations jjtn000 = new ASTOperations(JJTOPERATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Operations */
        try {
/*@egen*/
	<Operations> Operation() (<SemiColon> Operation())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Operation()            : {/*@bgen(jjtree) Operation */
  ASTOperation jjtn000 = new ASTOperation(JJTOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Operation */
        try {
/*@egen*/
	Entete_operation() <Equal> Substitution_corps_operation()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Entete_operation()                  : {/*@bgen(jjtree) EnteteOperation */
  ASTEnteteOperation jjtn000 = new ASTEnteteOperation(JJTENTETEOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) EnteteOperation */
        try {
/*@egen*/
	[<IDENTIFIER> (<Comma> <IDENTIFIER>)* <OperationReturn> ] Ident_ren()
	 [<OpenParen> <IDENTIFIER>(<Comma> <IDENTIFIER>)* <CloseParen>]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Terme()        : {/*@bgen(jjtree) Terme */
  ASTTerme jjtn000 = new ASTTerme(JJTTERME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Terme */
        try {
/*@egen*/
	Terme_simple()
| 	Expression_arithmetique()
| 	Terme_record() (<OpenParen> <Quote > <IDENTIFIER> <CloseParen>)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 

void Terme_simple()              : {/*@bgen(jjtree) TermeSimple */
  ASTTermeSimple jjtn000 = new ASTTermeSimple(JJTTERMESIMPLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) TermeSimple */
        try {
/*@egen*/
	Ident_ren() (<OpenParen> <Quote > <IDENTIFIER> <CloseParen>)*
| 	Entier_lit()
| 	Boolean_lit()
| 	<Boolean> <OpenParen> Condition() <CloseParen>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Entier_lit()             : {/*@bgen(jjtree) Entier_Lit */
  ASTEntier_Lit jjtn000 = new ASTEntier_Lit(JJTENTIER_LIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Entier_Lit */
        try {
/*@egen*/
	<Number>
| 	<MaxInt>
| 	<MinInt>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Boolean_lit()              : {/*@bgen(jjtree) Boolean_Lit */
  ASTBoolean_Lit jjtn000 = new ASTBoolean_Lit(JJTBOOLEAN_LIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Boolean_Lit */
        try {
/*@egen*/
	<False>
| 	<True>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Terme_record()               : {/*@bgen(jjtree) Terme_record */
  ASTTerme_record jjtn000 = new ASTTerme_record(JJTTERME_RECORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Terme_record */
        try {
/*@egen*/
	< Rec > <OpenParen > [<IDENTIFIER > <In >] (Terme() | Expr_tableau()) (< Comma > [<IDENTIFIER > <In >](Terme() | Expr_tableau()))* < CloseParen >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Expr_tableau()               : {/*@bgen(jjtree) Expr_tableau */
  ASTExpr_tableau jjtn000 = new ASTExpr_tableau(JJTEXPR_TABLEAU);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expr_tableau */
        try {
/*@egen*/
	< IDENTIFIER > 
| 	< OpenBraces > Terme_simple() (< Maplet > Terme_simple())* < Maplet > Terme() ( < Comma > Terme_simple() (< Maplet > Terme_simple())* < Maplet > Terme())* < CloseBraces >
| 	Ensemble_simple() (< Product > Ensemble_simple()) < Product > <OpenBraces > Terme() < CloseBraces >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Condition()            : {/*@bgen(jjtree) Condition */
  ASTCondition jjtn000 = new ASTCondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) Condition */
        try {
/*@egen*/
	Terme_simple() (< Equal > |  < NotEqual > |  < LessThan > |  < GreatherThan > |  < LessThanOrEqual > |< GreatherThanOrEqual >)	Terme_simple() CondBis()
| 	< Not > Condition() CondBis()
|   < OpenParen > Condition() < CloseParen > CondBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void CondBis() : { } {
	< And > Condition() CondBis()
| 	< Or > Condition() CondBis()
|   {}
}

void Instruction()             : {/*@bgen(jjtree) Instruction */
  ASTInstruction jjtn000 = new ASTInstruction(JJTINSTRUCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction */
        try {
/*@egen*/
	Instruction_bloc()
| 	Instruction_variable_locale()
| 	Substitution_identite()
| 	Instruction_devient_egal()
| 	Instruction_appel_operation()
| 	Instruction_conditionnelle()
| 	Instruction_cas()
| 	Instruction_assertion()
| 	Instruction_sequence()
| 	Substitution_tant_que()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Instruction_corps_operation()                             : {/*@bgen(jjtree) Instruction_corps_operation */
  ASTInstruction_corps_operation jjtn000 = new ASTInstruction_corps_operation(JJTINSTRUCTION_CORPS_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_corps_operation */
        try {
/*@egen*/
	Instruction_bloc()
| 	Instruction_variable_locale()
| 	Substitution_identite()
| 	Instruction_devient_egal()
| 	Instruction_appel_operation()
| 	Instruction_conditionnelle()
| 	Instruction_cas()
| 	Instruction_assertion()
| 	Substitution_tant_que()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Instruction_bloc()                   : {/*@bgen(jjtree) Instruction_bloc */
  ASTInstruction_bloc jjtn000 = new ASTInstruction_bloc(JJTINSTRUCTION_BLOC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_bloc */
        try {
/*@egen*/
	< Begin > Instruction() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Instruction_variable_locale()                              : {/*@bgen(jjtree) Instruciton_variable_locale */
  ASTInstruciton_variable_locale jjtn000 = new ASTInstruciton_variable_locale(JJTINSTRUCITON_VARIABLE_LOCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) Instruciton_variable_locale */
        try {
/*@egen*/
	< Var > < IDENTIFIER > (< Comma > < IDENTIFIER > )* < In > Instruction() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Instruction_devient_egal()                           : {/*@bgen(jjtree) Instruction_devient_egal */
  ASTInstruction_devient_egal jjtn000 = new ASTInstruction_devient_egal(JJTINSTRUCTION_DEVIENT_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_devient_egal */
        try {
/*@egen*/
	Ident_ren()
	(
	   [< OpenParen > Terme() (< Comma > Terme())* < CloseParen >] < DevientEgal > Terme()
		| < DevientEgal > Expr_tableau()
		| < Quote > < IDENTIFIER > ( < Quote > < IDENTIFIER > )* < DevientEgal > Terme()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Instruction_appel_operation()                              : {/*@bgen(jjtree) Instruction_appel_operation */
  ASTInstruction_appel_operation jjtn000 = new ASTInstruction_appel_operation(JJTINSTRUCTION_APPEL_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_appel_operation */
        try {
/*@egen*/
	[Ident_ren() (< Comma > Ident_ren())* < OperationReturn >] Ident_ren() [< OpenParen > (Terme() | < String >) (< Comma > (Terme() | < String >))* < CloseParen > ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/  
}

void Instruction_sequence()                       : {/*@bgen(jjtree) Instruction_sequence */
  ASTInstruction_sequence jjtn000 = new ASTInstruction_sequence(JJTINSTRUCTION_SEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_sequence */
        try {
/*@egen*/ 
	Instruction_bloc() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_variable_locale() < SemiColon > Instruction() InstrSeqBis() 
| 	Substitution_identite() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_devient_egal() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_appel_operation() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_conditionnelle() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_cas() < SemiColon > Instruction() InstrSeqBis() 
| 	Instruction_assertion() < SemiColon > Instruction() InstrSeqBis() 
| 	Substitution_tant_que() < SemiColon > Instruction() InstrSeqBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void InstrSeqBis()  : {} {
	< SemiColon > Instruction() InstrSeqBis()
|	{}
}

void Instruction_conditionnelle()                             : {/*@bgen(jjtree) Instruction_conditionnelle */
  ASTInstruction_conditionnelle jjtn000 = new ASTInstruction_conditionnelle(JJTINSTRUCTION_CONDITIONNELLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_conditionnelle */
        try {
/*@egen*/
	< If > Condition() < Then > Instruction() (< Elsif > Condition() < Then > Instruction())* [< Else > Instruction() ] < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/   
}

void Instruction_cas()                  : {/*@bgen(jjtree) Instruction_cas */
  ASTInstruction_cas jjtn000 = new ASTInstruction_cas(JJTINSTRUCTION_CAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_cas */
        try {
/*@egen*/
	< Case > Terme_simple() < Of > < Either > Terme_simple() (< Comma > Terme_simple() )* < Then > Instruction()
	( < Or > Terme_simple() (< Comma > Terme_simple() )* < Then > Instruction())*
	[< Else > Instruction() ]
	< End > < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Substitution_tant_que()                        : {/*@bgen(jjtree) Substitution_tant_que */
  ASTSubstitution_tant_que jjtn000 = new ASTSubstitution_tant_que(JJTSUBSTITUTION_TANT_QUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_tant_que */
        try {
/*@egen*/
	< While > Condition() < Do > Instruction() < Invariant > Predicat() < Variant > Expression() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/   
}

void Instruction_assertion()                        : {/*@bgen(jjtree) Instruction_assertion */
  ASTInstruction_assertion jjtn000 = new ASTInstruction_assertion(JJTINSTRUCTION_ASSERTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Instruction_assertion */
        try {
/*@egen*/
	< Assert > Condition() < Then > Instruction() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Predicat()           : {/*@bgen(jjtree) predicat */
  ASTpredicat jjtn000 = new ASTpredicat(JJTPREDICAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) predicat */
        try {
/*@egen*/
	Predicat_Parenthese() PredicatBis() 
| 	Predicat_Negation() PredicatBis() 
| 	Predicat_Universel() PredicatBis() 
| 	Predicat_Existentiel() PredicatBis() 
| 	Predicat_Egalite() PredicatBis() 
| 	Predicat_Inegalite() PredicatBis() 
| 	Predicat_Appartenance() PredicatBis() 
| 	Predicat_Non_Appartenance() PredicatBis() 
| 	Predicat_Inclusion() PredicatBis() 
| 	Predicat_Inclusion_Stricte() PredicatBis() 
| 	Predicat_Non_Inclusion() PredicatBis() 
| 	Predicat_Non_Inclusion_Stricte() PredicatBis() 
| 	Predicat_Inferieur_Ou_Egal() PredicatBis() 
| 	Predicat_Strictement_Inferieur() PredicatBis() 
| 	Predicat_Superieur_Ou_Egal() PredicatBis() 
| 	Predicat_Strictement_Superieur()  PredicatBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void PredicatBis() : { } {
	< And > Predicat() PredicatBis() 
| 	< Union > Predicat() PredicatBis() 
| 	< Implication > Predicat() PredicatBis() 
| 	< Equivalence > Predicat() PredicatBis() 
| { }
}

void  Predicat_Parenthese()                      : {/*@bgen(jjtree) Predicat_parenthese */
  ASTPredicat_parenthese jjtn000 = new ASTPredicat_parenthese(JJTPREDICAT_PARENTHESE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_parenthese */
try {
/*@egen*/
< OpenParen > Predicat() < CloseParen >/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/ 
}

void  Predicat_Negation()                    : {/*@bgen(jjtree) Predicat_Negation */
  ASTPredicat_Negation jjtn000 = new ASTPredicat_Negation(JJTPREDICAT_NEGATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Negation */
try {
/*@egen*/
< Not > < OpenParen > Predicat() < CloseParen >/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/ 
}

void  Predicat_Universel()                     : {/*@bgen(jjtree) Predicat_Universel */
  ASTPredicat_Universel jjtn000 = new ASTPredicat_Universel(JJTPREDICAT_UNIVERSEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Universel */
 try {
/*@egen*/
 < Forall > Liste_ident() < Point > < OpenParen > Predicat() < Implication > Predicat() < CloseParen >/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Existentiel()                       : {/*@bgen(jjtree) Predicat_Existentiel */
  ASTPredicat_Existentiel jjtn000 = new ASTPredicat_Existentiel(JJTPREDICAT_EXISTENTIEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Existentiel */
 try {
/*@egen*/
 < Exists >  Liste_ident() < Point > < OpenParen > Predicat() < CloseParen >/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Egalite()                   : {/*@bgen(jjtree) Predicat_Egalite */
  ASTPredicat_Egalite jjtn000 = new ASTPredicat_Egalite(JJTPREDICAT_EGALITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Egalite */
 try {
/*@egen*/
 Expression() < Equal > Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Inegalite()                     : {/*@bgen(jjtree) Predicat_Inegalite */
  ASTPredicat_Inegalite jjtn000 = new ASTPredicat_Inegalite(JJTPREDICAT_INEGALITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Inegalite */
 try {
/*@egen*/
 Expression() < NotEqual >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Appartenance()                        : {/*@bgen(jjtree) Predicat_Appartenance */
  ASTPredicat_Appartenance jjtn000 = new ASTPredicat_Appartenance(JJTPREDICAT_APPARTENANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Appartenance */
 try {
/*@egen*/
 Expression() < In > Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Non_Appartenance()                            : {/*@bgen(jjtree) Predicat_Not_Appartenance */
  ASTPredicat_Not_Appartenance jjtn000 = new ASTPredicat_Not_Appartenance(JJTPREDICAT_NOT_APPARTENANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Not_Appartenance */
 try {
/*@egen*/
 Expression() < NotSetMemberShip >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Inclusion()                     : {/*@bgen(jjtree) Predicat_Inclusion */
  ASTPredicat_Inclusion jjtn000 = new ASTPredicat_Inclusion(JJTPREDICAT_INCLUSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Inclusion */
 try {
/*@egen*/
 Expression() < Subset >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Inclusion_Stricte()                              : {/*@bgen(jjtree) Predicat_Insclusion_Stricte */
  ASTPredicat_Insclusion_Stricte jjtn000 = new ASTPredicat_Insclusion_Stricte(JJTPREDICAT_INSCLUSION_STRICTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Insclusion_Stricte */
 try {
/*@egen*/
 Expression() < StrictSubset >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Non_Inclusion()                         : {/*@bgen(jjtree) Predicat_Non_Inclusion */
  ASTPredicat_Non_Inclusion jjtn000 = new ASTPredicat_Non_Inclusion(JJTPREDICAT_NON_INCLUSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Non_Inclusion */
 try {
/*@egen*/
 Expression() < NotSubset >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Non_Inclusion_Stricte()                                 : {/*@bgen(jjtree) Predicat_Non_Inclusion_Stricte */
  ASTPredicat_Non_Inclusion_Stricte jjtn000 = new ASTPredicat_Non_Inclusion_Stricte(JJTPREDICAT_NON_INCLUSION_STRICTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Non_Inclusion_Stricte */
 try {
/*@egen*/
 Expression() < NotStrictSubset >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Inferieur_Ou_Egal()                             : {/*@bgen(jjtree) Predicat_Inferieur_Ou_Egal */
  ASTPredicat_Inferieur_Ou_Egal jjtn000 = new ASTPredicat_Inferieur_Ou_Egal(JJTPREDICAT_INFERIEUR_OU_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Inferieur_Ou_Egal */
 try {
/*@egen*/
 Expression() < LessThanOrEqual >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Strictement_Inferieur()                                 : {/*@bgen(jjtree) Predicat_Strictement_Inferieur */
  ASTPredicat_Strictement_Inferieur jjtn000 = new ASTPredicat_Strictement_Inferieur(JJTPREDICAT_STRICTEMENT_INFERIEUR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Strictement_Inferieur */
 try {
/*@egen*/
 Expression() < LessThan >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Strictement_Superieur()                                 : {/*@bgen(jjtree) Predicat_Strictement_Superieur */
  ASTPredicat_Strictement_Superieur jjtn000 = new ASTPredicat_Strictement_Superieur(JJTPREDICAT_STRICTEMENT_SUPERIEUR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Strictement_Superieur */
 try {
/*@egen*/
 Expression() < GreatherThan >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void  Predicat_Superieur_Ou_Egal()                             : {/*@bgen(jjtree) Predicat_Superieur_Ou_Egal */
  ASTPredicat_Superieur_Ou_Egal jjtn000 = new ASTPredicat_Superieur_Ou_Egal(JJTPREDICAT_SUPERIEUR_OU_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Predicat_Superieur_Ou_Egal */
 try {
/*@egen*/
 Expression() < GreatherThanOrEqual >  Expression()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void Expression()             : {/*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	Expression_primaire() ExpressionBis()
|   Expression_booleenne() ExpressionBis()
|   Expression_arithmetique() ExpressionBis()
|   Expression_d_ensembles() ExpressionBis()
|   Construction_d_ensembles() ExpressionBis()
|   Expression_de_relations() ExpressionBis()
|   Construction_de_fonctions() ExpressionBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpressionBis() : { } {
  ( < PartialFunction >|< TotalFunction >|< PartialInjection >|< TotalInjection >|< PartialSurjection >|< TotalSurjection >|< TotalBijection >|< Maplet >|< Comma >) Expression() ExpressionBis()
| {}
}   

void Expression_primaire ()                      : {/*@bgen(jjtree) Expression_primaire */
  ASTExpression_primaire jjtn000 = new ASTExpression_primaire(JJTEXPRESSION_PRIMAIRE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) Expression_primaire */
        try {
/*@egen*/
	Donnee()
| 	Expr_parenthesee()
| 	< String >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Expression_booleenne ()                       : {/*@bgen(jjtree) Expression_booleenne */
  ASTExpression_booleenne jjtn000 = new ASTExpression_booleenne(JJTEXPRESSION_BOOLEENNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) Expression_booleenne */
        try {
/*@egen*/
	Boolean_lit() 
| 	Conversion_bool()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}


void Expression_arithmetique()            : {/*@bgen(jjtree) ExprArith */
  ASTExprArith jjtn000 = new ASTExprArith(JJTEXPRARITH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ExprArith */
        try {
/*@egen*/
	Entier_lit() ExpArithBis() 
| 	Ident_ren() 
[
	(<OpenParen > Terme() (<Comma> Terme())* <CloseParen>)
	| (< Quote > <IDENTIFIER> (< Quote > <IDENTIFIER>)*)
]  ExpArithBis() 
|	< Minus > Expression_arithmetique() ExpArithBis() 
|  	< Succ > <OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis() 
|  	< Pred > <OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis() 
|	< OpenParen > Expression_arithmetique() < CloseParen >  ExpArithBis()
| 	< Max > < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Min > < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Card > < OpenParen > Expression_arithmetique() < CloseParen > ExpArithBis()
| 	< Sigma > Liste_ident() < Point > < OpenParen > Predicat() < SuchAs > Expression() < CloseParen > ExpArithBis()
| 	< Pi > Liste_ident() < Point > < OpenParen > Predicat() < SuchAs > Expression() < CloseParen > ExpArithBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpArithBis() : {} {
	< Plus > Expression_arithmetique()  ExpArithBis() 
| 	< Minus > Expression_arithmetique()  ExpArithBis() 
| 	< Product > Expression_arithmetique()  ExpArithBis() 
| 	< Division > Expression_arithmetique() ExpArithBis() 
| 	< Modulo > Expression_arithmetique()  ExpArithBis() 
| 	< Power > Expression_arithmetique()  ExpArithBis()
|   {}
}

void Expression_d_ensembles()                         : {/*@bgen(jjtree) Expression_d_ensembles */
  ASTExpression_d_ensembles jjtn000 = new ASTExpression_d_ensembles(JJTEXPRESSION_D_ENSEMBLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expression_d_ensembles */
        try {
/*@egen*/
	Ensemble_vide()
|   Ensemble_entier()
|   Ensemble_booleen()
|   Ensemble_chaines()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Construction_d_ensembles()                           : {/*@bgen(jjtree) Construction_d_ensembles */
  ASTConstruction_d_ensembles jjtn000 = new ASTConstruction_d_ensembles(JJTCONSTRUCTION_D_ENSEMBLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Construction_d_ensembles */
    try {
/*@egen*/
    <OpenBraces> ( (< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis()
|   Sous_ensembles() ConstrEnsembleBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis()
| 	< UnionGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis()
| 	< InterGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis()
| 	< UnionQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis()
| 	< InterQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis()
| 	Expression_primaire() ExpressionBis() (< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis()
|   Expression_booleenne() ExpressionBis() (< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis()
|   Expression_arithmetique() ExpressionBis() (< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis()
|   Expression_d_ensembles() ExpressionBis() (< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis()
|   Expression_de_relations() ExpressionBis() (< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis()
|   Construction_de_fonctions() ExpressionBis() (< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ConstrEnsembleBis() : { } {
	ExpressionBis() (< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis()
| 	{ }
}

void Construction_de_fonctions()                            : {/*@bgen(jjtree) Construction_de_fonctions */
  ASTConstruction_de_fonctions jjtn000 = new ASTConstruction_de_fonctions(JJTCONSTRUCTION_DE_FONCTIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Construction_de_fonctions */
        try {
/*@egen*/
	< Lambda > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrFonctionBis()
|   < OpenBraces > ((< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< UnionGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< InterGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< UnionQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< InterQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< Fnc > < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
| 	< Rel > < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
|   Sous_ensembles() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis()
|	Expression_primaire() ExpressionBis() ((< OpenParen >  Expression() < CloseParen > ) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_booleenne() ExpressionBis() ((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_arithmetique() ExpressionBis() ((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_d_ensembles() ExpressionBis() ((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
|   Expression_de_relations() ExpressionBis() ((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ConstrFonctionBis() : { } {
	ExpressionBis() ((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis()
| 	{ }
}

void Expression_de_relations()                          : {/*@bgen(jjtree) Expression_de_relations */
  ASTExpression_de_relations jjtn000 = new ASTExpression_de_relations(JJTEXPRESSION_DE_RELATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expression_de_relations */
        try {
/*@egen*/
	< Id > < OpenParen >  Expression() < CloseParen > ExprRelationBis() 
| 	< Prj1 > < OpenParen > Expression() < Comma > Expression() < CloseParen > ExprRelationBis()
| 	< Prj2 > < OpenParen > Expression() < Comma > Expression() < CloseParen > ExprRelationBis()
| 	< Dom > < OpenParen >  Expression() < CloseParen > ExprRelationBis()
| 	< Ran > < OpenParen >  Expression() < CloseParen > ExprRelationBis()
|   <OpenBraces> ( (< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
|   Sous_ensembles() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
|   Sous_ensembles() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
|   Sous_ensembles_finis()  ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< UnionGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< InterGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< UnionQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< InterQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )) ExprRelationBis()
| 	< Lambda > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
|   <OpenBraces> ((< IDENTIFIER > (< Comma > < IDENTIFIER >)* < SuchAs > Predicat()) | (Expression() (< Comma > Expression())*) )< CloseBraces > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< UnionGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< InterGen > < OpenParen >  Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< UnionQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< InterQuant > Liste_ident() < Point > < OpenParen >  Predicat() < SuchAs > Expression() < CloseParen > ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< Fnc > < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	< Rel > < OpenParen >  Expression() < CloseParen > ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))) ExprRelationBis()
| 	Expression_primaire() ExpressionBis() (((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen > ) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
|   Expression_booleenne() ExpressionBis() (((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
|   Expression_arithmetique() ExpressionBis() (((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
|   Expression_d_ensembles() ExpressionBis() (((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExprRelationBis() : { } {
	ExpressionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | (Expression_de_relations() ExpressionBis() ((< OpenParen >  Expression() < CloseParen >) | ((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() ExpressionBis() < OpenParen >  Expression() < CloseParen >)) ConstrFonctionBis() (((< Product > | < NatRange > | < Minus > | < Union > |< Intersection > ) Expression() ConstrEnsembleBis() (( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > ))) | ((( < Relation > | < SemiColon > | < DirectProduct > | < Parallel > | < Power > | < DomainRestriction > | < DomainSubstraction > | < RangeRestriction > | < RangeSubstraction > | < Override >) |( < OpenCurly > Expression() < CloseCurly > | < Closure > | < Closure1 > | < Tilde > )))))) ExprRelationBis()
| { }
}

void Expr_parenthesee()                   : {/*@bgen(jjtree) Expr_parenthesee */
  ASTExpr_parenthesee jjtn000 = new ASTExpr_parenthesee(JJTEXPR_PARENTHESEE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expr_parenthesee */
        try {
/*@egen*/
	< OpenParen > Expression() < CloseParen >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Conversion_bool()                  : {/*@bgen(jjtree) Conversion_bool */
  ASTConversion_bool jjtn000 = new ASTConversion_bool(JJTCONVERSION_BOOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Conversion_bool */
        try {
/*@egen*/
	< Bool > < OpenParen > Predicat() < CloseParen >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Ensemble_vide()                : {/*@bgen(jjtree) Ensemble_vide */
  ASTEnsemble_vide jjtn000 = new ASTEnsemble_vide(JJTENSEMBLE_VIDE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Ensemble_vide */
        try {
/*@egen*/
	< EmptySet >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void Ensemble_entier()                  : {/*@bgen(jjtree) Ensemble_entier */
  ASTEnsemble_entier jjtn000 = new ASTEnsemble_entier(JJTENSEMBLE_ENTIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Ensemble_entier */
        try {
/*@egen*/
	< Nat >
| 	< Nat1 >
| 	< Natural >
| 	< Natural1 >
| 	< Int >
| 	< Integer >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/  
}

void Ensemble_chaines()                   : {/*@bgen(jjtree) Ensemble_chaines */
  ASTEnsemble_chaines jjtn000 = new ASTEnsemble_chaines(JJTENSEMBLE_CHAINES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Ensemble_chaines */
        try {
/*@egen*/
	< String >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Ensemble_booleen()                   : {/*@bgen(jjtree) Ensemble_booleen */
  ASTEnsemble_booleen jjtn000 = new ASTEnsemble_booleen(JJTENSEMBLE_BOOLEEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Ensemble_booleen */
        try {
/*@egen*/
	< Bool >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Sous_ensembles()                 : {/*@bgen(jjtree) Sous_ensembles */
  ASTSous_ensembles jjtn000 = new ASTSous_ensembles(JJTSOUS_ENSEMBLES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Sous_ensembles */
        try {
/*@egen*/
	< POW > < OpenParen >  Expression() < CloseParen >
|	< POW1 > < OpenParen >  Expression() < CloseParen >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Sous_ensembles_finis()                       : {/*@bgen(jjtree) Sous_ensembles_finis */
  ASTSous_ensembles_finis jjtn000 = new ASTSous_ensembles_finis(JJTSOUS_ENSEMBLES_FINIS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Sous_ensembles_finis */
    try {
/*@egen*/
    < FIN > < OpenParen >  Expression() < CloseParen >
|   < FIN1 > < OpenParen >  Expression() < CloseParen >/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Substitution()               : {/*@bgen(jjtree) Substitution */
  ASTSubstitution jjtn000 = new ASTSubstitution(JJTSUBSTITUTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution */
        try {
/*@egen*/
	Substitution_bloc() SubstitutionBis() 
|	Substitution_identite() SubstitutionBis() 
|	Substitution_devient_egal() SubstitutionBis() 
|	Substitution_precondition() SubstitutionBis() 
|	Substitution_assertion() SubstitutionBis() 
|	Substitution_choix_borne() SubstitutionBis() 
|	Substitution_conditionnelle() SubstitutionBis() 
|	Substitution_selection() SubstitutionBis() 
|	Substitution_cas() SubstitutionBis() 
|	Substitution_choix_non_borne() SubstitutionBis() 
|	Substitution_definition_locale() SubstitutionBis() 
|	Substitution_devient_elt_de() SubstitutionBis() 
|	Substitution_devient_tel_que() SubstitutionBis() 
|	Substitution_variable_locale() SubstitutionBis() 
|	Substitution_appel_operation()  SubstitutionBis() 
|	Substitution_tant_que()  SubstitutionBis()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void SubstitutionBis() : { } {
 	< SemiColon > Substitution() SubstitutionBis() 
|	< Parallel > Substitution() SubstitutionBis() 
| { }	
}

void Substitution_corps_operation()                               : {/*@bgen(jjtree) Substitution_corps_operation */
  ASTSubstitution_corps_operation jjtn000 = new ASTSubstitution_corps_operation(JJTSUBSTITUTION_CORPS_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_corps_operation */
        try {
/*@egen*/
	Substitution_bloc()
|	Substitution_identite()
|	Substitution_devient_egal()
|	Substitution_precondition()
|	Substitution_assertion()
|	Substitution_choix_borne()
|	Substitution_conditionnelle()
|	Substitution_selection()
|	Substitution_cas()
|	Substitution_choix_non_borne()
|	Substitution_definition_locale()
|	Substitution_devient_elt_de()
|	Substitution_devient_tel_que()
|	Substitution_variable_locale()
|	Substitution_appel_operation()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_bloc()                    : {/*@bgen(jjtree) Substitution_bloc */
  ASTSubstitution_bloc jjtn000 = new ASTSubstitution_bloc(JJTSUBSTITUTION_BLOC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_bloc */
        try {
/*@egen*/
	< Begin > Substitution() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_identite()                        : {/*@bgen(jjtree) Substitution_identite */
  ASTSubstitution_identite jjtn000 = new ASTSubstitution_identite(JJTSUBSTITUTION_IDENTITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_identite */
        try {
/*@egen*/
	< Skip >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_devient_egal()                            : {/*@bgen(jjtree) Substitution_devient_egal */
  ASTSubstitution_devient_egal jjtn000 = new ASTSubstitution_devient_egal(JJTSUBSTITUTION_DEVIENT_EGAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_devient_egal */
        try {
/*@egen*/
	Ident_ren()
	(
	  (< Comma > Ident_ren())* < DevientEgal > Expression() (< Comma > Expression())*
		|	< OpenParen > Expression() (< Comma > Expression())* < CloseParen > < DevientEgal > Expression()
		|	< Quote > < IDENTIFIER > (< Quote > < IDENTIFIER >)* < DevientEgal > Expression()
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_precondition()                            : {/*@bgen(jjtree) Substitution_precondition */
  ASTSubstitution_precondition jjtn000 = new ASTSubstitution_precondition(JJTSUBSTITUTION_PRECONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_precondition */
        try {
/*@egen*/
	< Pre > Predicat() < Then > Substitution() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_assertion()                         : {/*@bgen(jjtree) Substitution_assertion */
  ASTSubstitution_assertion jjtn000 = new ASTSubstitution_assertion(JJTSUBSTITUTION_ASSERTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_assertion */
        try {
/*@egen*/
	< Assert > Predicat() < Then > Substitution() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_choix_borne()                           : {/*@bgen(jjtree) Substitution_choix_borne */
  ASTSubstitution_choix_borne jjtn000 = new ASTSubstitution_choix_borne(JJTSUBSTITUTION_CHOIX_BORNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_choix_borne */
        try {
/*@egen*/
	< Choice > Substitution() ( < OrC > Substitution() )* < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_conditionnelle()                              : {/*@bgen(jjtree) Substitution_conditionnelle */
  ASTSubstitution_conditionnelle jjtn000 = new ASTSubstitution_conditionnelle(JJTSUBSTITUTION_CONDITIONNELLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_conditionnelle */
        try {
/*@egen*/
	< If > Predicat() < Then > Substitution()
	( < Elsif > Predicat() < Then > Substitution() )*
	[ < Else > Substitution() ]
	< End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_selection()                         : {/*@bgen(jjtree) Substitution_selection */
  ASTSubstitution_selection jjtn000 = new ASTSubstitution_selection(JJTSUBSTITUTION_SELECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_selection */
        try {
/*@egen*/
	< Select > Predicat() < Then > Substitution()
	( < When > Predicat() < Then > Substitution() )*
	[ < Else > Substitution()]
	< End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_cas()                   : {/*@bgen(jjtree) Substitution_cas */
  ASTSubstitution_cas jjtn000 = new ASTSubstitution_cas(JJTSUBSTITUTION_CAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_cas */
        try {
/*@egen*/
	< Case > Expression() < Of >
	< Either > Terme_simple() (< Comma > Terme_simple())* < Then > Substitution()
	( < OrC > Terme_simple() (< Comma > Terme_simple())* < Then > Substitution() )*
	[ < Else > Substitution() ]
	< End >
	< End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_choix_non_borne()                               : {/*@bgen(jjtree) Substitution_choix_non_borne */
  ASTSubstitution_choix_non_borne jjtn000 = new ASTSubstitution_choix_non_borne(JJTSUBSTITUTION_CHOIX_NON_BORNE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_choix_non_borne */
        try {
/*@egen*/
	< Any > < IDENTIFIER > (< Comma > < IDENTIFIER >)* < Where > Predicat() < Then > Substitution() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_definition_locale()                                 : {/*@bgen(jjtree) Substitution_definition_locale */
  ASTSubstitution_definition_locale jjtn000 = new ASTSubstitution_definition_locale(JJTSUBSTITUTION_DEFINITION_LOCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_definition_locale */
        try {
/*@egen*/
	< Let > < IDENTIFIER > (< Comma > < IDENTIFIER >)* < Be >
	< IDENTIFIER > < Equal > Expression() ( < ConcatSequence > < IDENTIFIER > < Equal > Expression() )*
	< InLetVar > Substitution() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_devient_elt_de()                              : {/*@bgen(jjtree) Substitution_devient_elt_de */
  ASTSubstitution_devient_elt_de jjtn000 = new ASTSubstitution_devient_elt_de(JJTSUBSTITUTION_DEVIENT_ELT_DE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_devient_elt_de */
        try {
/*@egen*/
	Ident_ren()(< Comma > < IDENTIFIER >)* < SetIn > Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_devient_tel_que()                               : {/*@bgen(jjtree) Substitution_devient_tel_que */
  ASTSubstitution_devient_tel_que jjtn000 = new ASTSubstitution_devient_tel_que(JJTSUBSTITUTION_DEVIENT_TEL_QUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_devient_tel_que */
        try {
/*@egen*/
	Ident_ren()(< Comma > Ident_ren())* < In > < OpenParen > Predicat() < CloseParen >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_variable_locale()                               : {/*@bgen(jjtree) Substitution_variable_locale */
  ASTSubstitution_variable_locale jjtn000 = new ASTSubstitution_variable_locale(JJTSUBSTITUTION_VARIABLE_LOCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_variable_locale */
        try {
/*@egen*/
	< Var > < IDENTIFIER >(< Comma > Ident_ren())* < InLetVar > Substitution() < End >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Substitution_appel_operation()                               : {/*@bgen(jjtree) Substitution_appel_operation */
  ASTSubstitution_appel_operation jjtn000 = new ASTSubstitution_appel_operation(JJTSUBSTITUTION_APPEL_OPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Substitution_appel_operation */
        try {
/*@egen*/
	[ Ident_ren()(< Comma > Ident_ren())* < OperationReturn > ] Ident_ren() [ < OpenParen > Expression()(< Comma > Expression())* < CloseParen > ]/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Liste_ident()              : {/*@bgen(jjtree) Liste_ident */
  ASTListe_ident jjtn000 = new ASTListe_ident(JJTLISTE_IDENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Liste_ident */
        try {
/*@egen*/  
	< IDENTIFIER >
| 	< OpenParen > < IDENTIFIER >  (< Comma > < IDENTIFIER >)* < CloseParen >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Ensemble_simple()                  : {/*@bgen(jjtree) Ensemble_simple */
  ASTEnsemble_simple jjtn000 = new ASTEnsemble_simple(JJTENSEMBLE_SIMPLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) Ensemble_simple */
        try {
/*@egen*/ 
	< Bool > 
| 	< IDENTIFIER >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}